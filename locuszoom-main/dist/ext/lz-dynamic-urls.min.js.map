{"version":3,"sources":["webpack://[name]/webpack/bootstrap","webpack://[name]/webpack/runtime/define property getters","webpack://[name]/webpack/runtime/hasOwnProperty shorthand","webpack://[name]/./esm/ext/lz-dynamic-urls.js"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","_parseQueryParams","queryString","query","pairs","substr","split","i","length","pair","decodeURIComponent","_extractValues","data","mapping","reverse","ret","newMapping","keys","forEach","k","asName","_setStateFromUrlHandler","plot","stateData","applyState","_setUrlFromStateHandler","state","paramsFromUrl","window","location","search","extractValues","plotUpdatesUrl","callback","listener","eventContext","oldParams","serializedPlotData","newParams","assign","some","paramsObj","map","encodeURIComponent","join","history","pushState","document","title","replaceState","on","plotWatchesUrl","event","urlData","addEventListener","trackExternalListener"],"mappings":";qCACA,IAAIA,EAAsB,CCA1B,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3E,EAAwB,CAACM,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,I,KCuDlF,SAASI,EAAkBC,GAIvB,MAAMC,EAAQ,GACd,GAAID,EAAa,CACb,MAAME,GAA4B,MAAnBF,EAAY,GAAaA,EAAYG,OAAO,GAAKH,GAAaI,MAAM,KACnF,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAMI,OAAQD,IAAK,CACnC,MAAME,EAAOL,EAAMG,GAAGD,MAAM,KAC5BH,EAAMO,mBAAmBD,EAAK,KAAOC,mBAAmBD,EAAK,IAAM,KAG3E,OAAON,EAIX,SAASQ,EAAeC,EAAMC,EAASC,GAMnC,MAAMC,EAAM,GACZ,IAAIC,EAAaH,EAejB,OAlBAC,EAAUA,IAAW,KAKjBE,EAAa,GACbxB,OAAOyB,KAAKJ,GAASK,SAAQ,SAASC,GAClCH,EAAWH,EAAQM,IAAMA,MAIjC3B,OAAOyB,KAAKD,GAAYE,SAAQ,SAASC,GACrC,MAAMC,EAASJ,EAAWG,GACtB3B,OAAOM,UAAUC,eAAeC,KAAKY,EAAMO,KAC3CJ,EAAIK,GAAUR,EAAKO,OAIpBJ,EAGX,SAASM,EAAwBC,EAAMC,GAGnCD,EAAKE,WAAWD,GAGpB,SAASE,EAAwBH,EAAMT,GAOnC,OAAOF,EAAeW,EAAKI,MAAOb,GAUtC,SAASc,EAAcd,EAASX,GAI5B,OAAOS,EADaV,EADpBC,EAAcA,GAAe0B,OAAOC,SAASC,QAEVjB,GAAS,G,uBA0EhD,MAOA,EAPY,CACRc,gBACAI,cAAepB,EACfqB,eArCJ,SAAwBV,EAAMT,EAASoB,GACnCA,EAAWA,GAAYR,EAGvB,MAAMS,EAAW,SAAUC,GACvB,MAAMC,EAAYnC,EAAkB2B,OAAOC,SAASC,QAE9CO,EAAqBJ,EAASX,EAAMT,EAASsB,GAC7CG,EAAY9C,OAAO+C,OAAO,GAAIH,EAAWC,GAO/C,GALe7C,OAAOyB,KAAKqB,GAAWE,MAAK,SAAUrB,GAGjD,OAAQiB,EAAUjB,IAAMmB,EAAUnB,MAE1B,CACR,MAAMjB,GArIauC,EAqIuBH,EAlI3C,IACH9C,OAAOyB,KAAKwB,GAAWC,KAAI,SAASpD,GAChC,MAAO,GAAGqD,mBAAmBrD,MAAQqD,mBAAmBF,EAAUnD,SACnEsD,KAAK,QAiIApD,OAAOyB,KAAKmB,GAAW5B,OACvBqC,QAAQC,UAAU,GAAIC,SAASC,MAAO9C,GAItC2C,QAAQI,aAAa,GAAIF,SAASC,MAAO9C,GA5IzD,IAA+BuC,GAkJ3B,OADAnB,EAAK4B,GAAG,gBAAiBhB,GAClBA,GASPiB,eA9DJ,SAAwB7B,EAAMT,EAASoB,GACnCA,EAAWA,GAAYZ,EAEvB,MAAMa,EAAW,SAAUkB,GACvB,MAAMC,EAAU1B,EAAcd,GAE9BoB,EAASX,EAAM+B,IAInB,OAFAzB,OAAO0B,iBAAiB,WAAYpB,GACpCZ,EAAKiC,sBAAsB3B,OAAQ,WAAYM,GACxCA,I","file":"ext/lz-dynamic-urls.min.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\n * Optional LocusZoom extension: must be included separately, and after LocusZoom has been loaded\n *\n * This plugin exports helper functions, but does not modify the global registry. It does not require `LocusZoom.use`.\n *\n * Demonstrates a mechanism by which the plot can be loaded to a specific initial state based on the URL query string\n *  (and, optionally, to update the URL bar when the plot state changes, with back button support)\n *\n * This makes it possible to create \"direct links\" to a particular plot of interest (and go back to a previous state\n *  as the user interacts with the page). Optionally, there is support for custom callbacks to connect the URL to\n *  arbitrarily complex plot behaviors.\n *\n * To use in an environment without special JS build tooling, simply load the extension file as JS from a CDN (after any dependencies):\n * ```\n * <script src=\"https://cdn.jsdelivr.net/npm/locuszoom@INSERT_VERSION_HERE/dist/ext/lz-dynamic-urls.min.js\" type=\"application/javascript\"></script>\n * ```\n *\n * To use with ES6 modules, import the helper functions and use them with your layout:\n *\n * ```\n * import LzDynamicUrls from 'locuszoom/esm/ext/lz-dynamic-urls';\n * ```\n *\n * After loading, bind the plot and URL as follows:\n * ```\n * // Declares which fields in plot.state will be mapped to and from the URL, eg `plot.state.chr` -> `example.com?chrom=X`\n * const stateUrlMapping = {chr: \"chrom\", start: \"start\", end: \"end\"};\n * // Fetch initial position from the URL, or use some defaults\n * let initialState = LzDynamicUrls.paramsFromUrl(stateUrlMapping);\n * if (!Object.keys(initialState).length) {\n *     initialState = {chr: 10, start: 114550452, end: 115067678};\n * }\n * layout = LocusZoom.Layouts.get(\"plot\", \"standard_association\", {state: initialState});\n * const plot = LocusZoom.populate(\"#lz-plot\", data_sources, layout);\n * // Once the plot has been created, we can bind it to the URL as follows. This will cause the URL to change whenever\n * //  the plot region changes, or, clicking the back button in your browser will reload the last region viewed\n * LzDynamicUrls.plotUpdatesUrl(plot, stateUrlMapping);\n * LzDynamicUrls.plotWatchesUrl(plot, stateUrlMapping);\n *\n * // NOTE: If you are building a page that adds/removes plots on the fly, event listeners will be cleaned up when\n * //   the destructor `plot.destroy()` is called\n * ```\n *\n *  @module\n */\n\nfunction _serializeQueryParams(paramsObj) {\n    // Serialize an object of parameter values into a query string\n    // TODO: Improve support for array values v[]=1&v[]=2\n    return `?${\n        Object.keys(paramsObj).map(function(key) {\n            return `${encodeURIComponent(key)}=${encodeURIComponent(paramsObj[key])}`;\n        }).join('&')}`;\n}\n\nfunction _parseQueryParams(queryString) {\n    // Parse a query string into an object of parameter values.\n    //   Does not attempt any type coercion; all values are, therefore, strings.\n    // TODO future: Support arrays / params that specify more than one value\n    const query = {};\n    if (queryString) {\n        const pairs = (queryString[0] === '?' ? queryString.substr(1) : queryString).split('&');\n        for (let i = 0; i < pairs.length; i++) {\n            const pair = pairs[i].split('=');\n            query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');\n        }\n    }\n    return query;\n}\n\n// A useful helper function for serializing values from a provided object\nfunction _extractValues(data, mapping, reverse) {\n    // Use the mapping to convert between {stateField: urlParam} (or the reverse). Any fields not referenced in\n    //  the \"key\" side of the mapping will be omitted from the return value.\n    // Likewise, will omit any requested keys that the source side of the mapping has no information for\n    reverse = reverse || false;\n\n    const ret = {};\n    let newMapping = mapping;\n    if (reverse) {\n        newMapping = {};\n        Object.keys(mapping).forEach(function(k) {\n            newMapping[mapping[k]] = k;\n        });\n    }\n\n    Object.keys(newMapping).forEach(function(k) {\n        const asName = newMapping[k];\n        if (Object.prototype.hasOwnProperty.call(data, k)) {\n            ret[asName] = data[k];\n        }\n\n    });\n    return ret;\n}\n\nfunction _setStateFromUrlHandler(plot, stateData) {\n    // A default way to deal with URL changes: push all the params as state into plot and rerender\n    // More complex handlers are possible- example, URL parameters could be used to add or remove data layers\n    plot.applyState(stateData);\n}\n\nfunction _setUrlFromStateHandler(plot, mapping) {\n    // Serialize and return basic query params based solely on information from plot.state\n    // More complex handlers are possible- the serializer can extract any information desired because it is given\n    //  a direct reference to the plot object\n\n    // This default method does not use the eventContext data, because so many things change plot.state without\n    //  officially triggering an event.\n    return _extractValues(plot.state, mapping);\n}\n\n/**\n * Extract plot parameters from the URL query string. Very useful for setting up the plot on initial page load.\n * @param {object} mapping How to map elements of plot state to URL param fields. Hash of\n *      {plotFieldName: urlParamName} entries (both values should be unique)\n * @param {string} [queryString='window.location.search'] The query string to parse\n * @returns {object} Plot parameter values\n */\nfunction paramsFromUrl(mapping, queryString) {\n    // Internal helper function: second argument only used for unit testing\n    queryString = queryString || window.location.search;\n    const queryParams = _parseQueryParams(queryString);\n    return _extractValues(queryParams, mapping, true);\n}\n\n/**\n * Allows the plot to monitor changes in the URL and take action when the URL changes.\n *\n * For example, this enables using the browser back button to jump to a previous plot after user interaction.\n *\n * @param {Plot} plot A reference to the LZ plot\n * @param {object} mapping How to map elements of plot state to URL param fields. Hash of\n *      {plotFieldName: urlParamName} entries (both values should be unique)\n * @param {function} [callback] Specify how the plot acts on information read in from query params.\n *   The default behavior is to push the data into `plot.state`\n *   Signature is function(plot, plotDataFromQueryString)\n * @returns {function} The function handle for the new listener (allows cleanup if plot is removed later)\n */\nfunction plotWatchesUrl(plot, mapping, callback) {\n    callback = callback || _setStateFromUrlHandler;\n\n    const listener = function (event) {\n        const urlData = paramsFromUrl(mapping);\n        // Tell the plot what to do with the params extracted from the URL\n        callback(plot, urlData);\n    };\n    window.addEventListener('popstate', listener);\n    plot.trackExternalListener(window, 'popstate', listener);\n    return listener;\n}\n\n/**\n * Update the URL whenever the plot state changes\n * @param {Plot} plot A reference to the LZ plot\n * @param {object} mapping How to map elements of plot state to URL param fields. Hash of\n *      {plotFieldName: urlParamName} entries (both values should be unique)\n * @param {function} [callback] Specify how plot data will be serialized into query params\n *   The default behavior is to extract all the URL params from plot.state as the only source.\n *   Signature is function(plot, mapping, eventContext)\n * @returns {function} The function handle for the new listener (allows cleanup if plot is removed later)\n * @listens event:state_changed\n */\nfunction plotUpdatesUrl(plot, mapping, callback) {\n    callback = callback || _setUrlFromStateHandler;\n    // Note: this event only fires when applyState receives *new* information that would trigger a rerender.\n    // Plot state is sometimes changed without the event being fired.\n    const listener = function (eventContext) {\n        const oldParams = _parseQueryParams(window.location.search);\n        // Apply custom serialization to convert plot data to URL params\n        const serializedPlotData = callback(plot, mapping, eventContext);\n        const newParams = Object.assign({}, oldParams, serializedPlotData);\n\n        const update = Object.keys(newParams).some(function (k) {\n            // Not every state change would affect the URL. Allow type coercion since query is a string.\n            // eslint-disable-next-line eqeqeq\n            return (oldParams[k] != newParams[k]);\n        });\n        if (update) {\n            const queryString = _serializeQueryParams(newParams);\n\n            if (Object.keys(oldParams).length) {\n                history.pushState({}, document.title, queryString);\n            } else {\n                // Prevent broken back behavior on first page load: the first time query params are set,\n                //  we don't generate a separate history entry\n                history.replaceState({}, document.title, queryString);\n            }\n\n        }\n    };\n    plot.on('state_changed', listener);\n    return listener;\n}\n\n// Slight build quirk: we use a single webpack file for all modules, but `libraryTarget` expects the entire\n//  module to be exported as `default` in <script> tag mode.\nconst all = {\n    paramsFromUrl,\n    extractValues: _extractValues,\n    plotUpdatesUrl,\n    plotWatchesUrl,\n};\n\nexport default all;\nexport { paramsFromUrl, _extractValues as extractValues, plotUpdatesUrl, plotWatchesUrl };\n"],"sourceRoot":""}