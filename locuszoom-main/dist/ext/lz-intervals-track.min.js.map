{"version":3,"sources":["webpack://[name]/webpack/bootstrap","webpack://[name]/webpack/runtime/define property getters","webpack://[name]/webpack/runtime/hasOwnProperty shorthand","webpack://[name]/external \"d3\"","webpack://[name]/./esm/ext/lz-intervals-track.js"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","d3","XCS","Symbol","for","YCS","XCE","YCE","install","LocusZoom","BaseUMAdapter","Adapters","_Button","Widgets","_BaseWidget","to_rgb","parameters","value","default_layout","start_field","end_field","track_label_field","track_split_field","track_split_order","track_split_legend_to_y_axis","split_tracks","track_height","track_vertical_spacing","bounding_box_padding","always_hide_legend","color","fill_opacity","tooltip_positioning","BaseLayer","DataLayers","intervals_tooltip_layout","closable","show","or","hide","and","html","intervals_layer_layout","namespace","id","type","tag","id_field","field","scale_function","categories","values","null_value","legend","behaviors","onmouseover","action","status","onmouseout","onclick","exclusive","onshiftclick","tooltip","bed_intervals_layer_layout","Layouts","merge","intervals_panel_layout","min_height","height","margin","top","right","bottom","left","toolbar","l","widgets","push","data_layer_id","position","axes","interaction","drag_background_to_pan","scroll_to_zoom","x_linked","hidden","orientation","origin","x","y","pad_from_bottom","data_layers","bed_intervals_panel_layout","intervals_plot_layout","state","width","responsive_resize","min_region_scale","max_region_scale","panels","add","request_options","query","this","_config","source","chr","end","start","super","_getURL","layout","arguments","_previous_categories","_categories","initialize","_statusnodes_group","svg","group","append","attr","_datanodes_group","data","result","forEach","item","item_key","allow_overlap","grouped_data","index","i","length","row_to_test","last_item","x_scale","parent","_arrangeTrackSplit","_arrangeTracksLinear","keys","reverse","row_index","getTrackHeight","track","reduce","acc","val","concat","element","getBaseId","replace","self","base_layout","_base_layout","render_layout","base_color_scale","find","color_scale","Error","has_colors","has_legend","rgb_option","rgb_field","known_categories","_generateCategoriesFromData","colors","_makeColorScheme","map","pair","shape","label","_applyLayoutOptions","assigned_data","_assignTracks","every","updateSplitTrackAxis","track_data","_applyFilters","selectAll","remove","status_nodes","enter","d","getElementStatusNodeId","cliparea","Math","max","exit","data_nodes","getElementId","resolveScalableParameter","applyBehaviors","bind","render","x_min","x_max","y_min","y_max","legend_axis","tracks","track_spacing","target_height","scaleHeightToData","ticks","range","findIndex","abs","text","y_axis","axis","floor","ceiling","parent_plot","positionPanels","category_info","n_categories","unique_ids","ScaleFunctions","parent_panel","data_layer","button","setHtml","setColor","setTitle","setOnclick","toggleSplitTracks","scale_timeout","clearTimeout","setTimeout","update","use"],"mappings":"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","file":"ext/lz-intervals-track.min.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const __WEBPACK_NAMESPACE_OBJECT__ = d3;","/**\n * Interval annotation track (for chromatin state, etc). Useful for BED file data with non-overlapping intervals.\n *  This is not part of the core LocusZoom library, but can be included as a standalone file.\n *\n * ### Features provided\n * * {@link module:LocusZoom_Adapters~IntervalLZ}\n * * {@link module:LocusZoom_Widgets~toggle_split_tracks}\n * * {@link module:LocusZoom_ScaleFunctions~to_rgb}\n * * {@link module:LocusZoom_DataLayers~intervals}\n * * {@link module:LocusZoom_Layouts~standard_intervals}\n * * {@link module:LocusZoom_Layouts~bed_intervals_layer}\n * * {@link module:LocusZoom_Layouts~intervals_layer}\n * * {@link module:LocusZoom_Layouts~intervals}\n * * {@link module:LocusZoom_Layouts~bed_intervals}\n * * {@link module:LocusZoom_Layouts~interval_association}\n *\n * ### Loading and usage\n * The page must incorporate and load all libraries before this file can be used, including:\n * - LocusZoom\n *\n * To use in an environment without special JS build tooling, simply load the extension file as JS from a CDN (after any dependencies):\n * ```\n * <script src=\"https://cdn.jsdelivr.net/npm/locuszoom@INSERT_VERSION_HERE/dist/ext/lz-intervals-track.min.js\" type=\"application/javascript\"></script>\n * ```\n *\n * To use with ES6 modules, the plugin must be loaded and registered explicitly before use:\n * ```\n * import LocusZoom from 'locuszoom';\n * import IntervalsTrack from 'locuszoom/esm/ext/lz-intervals-track';\n * LocusZoom.use(IntervalsTrack);\n * ```\n *\n * Then use the features made available by this extension. (see demos and documentation for guidance)\n * @module\n */\n\nimport * as d3 from 'd3';\n\n\n// Coordinates (start, end) are cached to facilitate rendering\nconst XCS = Symbol.for('lzXCS');\nconst YCS = Symbol.for('lzYCS');\nconst XCE = Symbol.for('lzXCE');\nconst YCE = Symbol.for('lzYCE');\n\n\nfunction install (LocusZoom) {\n    const BaseUMAdapter = LocusZoom.Adapters.get('BaseUMAdapter');\n    const _Button = LocusZoom.Widgets.get('_Button');\n    const _BaseWidget = LocusZoom.Widgets.get('BaseWidget');\n\n    /**\n     * (**extension**) Retrieve Interval Annotation Data (e.g. BED Tracks), as fetched from the LocusZoom API server (or compatible)\n     * @public\n     * @alias module:LocusZoom_Adapters~IntervalLZ\n     * @see module:LocusZoom_Adapters~BaseUMAdapter\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     * @param {number} config.params.source The numeric ID for a specific dataset as assigned by the API server\n     */\n    class IntervalLZ extends BaseUMAdapter {\n        _getURL(request_options) {\n            const source = this._config.source;\n            const query = `?filter=id in ${source} and chromosome eq '${request_options.chr}' and start le ${request_options.end} and end ge ${request_options.start}`;\n\n            const base = super._getURL(request_options);\n            return `${base}${query}`;\n        }\n    }\n\n    /**\n     * (**extension**) Button to toggle split tracks mode in an intervals track. This button only works as a panel-level toolbar\n     *   and when used with an intervals data layer from this extension.\n     * @alias module:LocusZoom_Widgets~toggle_split_tracks\n     * @see module:LocusZoom_Widgets~BaseWidget\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    class ToggleSplitTracks extends _BaseWidget {\n        /**\n         * @param {string} layout.data_layer_id The ID of the data layer that this button is intended to control.\n         */\n        constructor(layout) {\n            super(...arguments);\n            if (!layout.data_layer_id) {\n                layout.data_layer_id = 'intervals';\n            }\n            if (!this.parent_panel.data_layers[layout.data_layer_id]) {\n                throw new Error('Toggle split tracks widget specifies an invalid data layer ID');\n            }\n        }\n\n        update() {\n            const data_layer = this.parent_panel.data_layers[this.layout.data_layer_id];\n            const html = data_layer.layout.split_tracks ? 'Merge Tracks' : 'Split Tracks';\n            if (this.button) {\n                this.button.setHtml(html);\n                this.button.show();\n                this.parent.position();\n                return this;\n            } else {\n                this.button = new _Button(this)\n                    .setColor(this.layout.color)\n                    .setHtml(html)\n                    .setTitle('Toggle whether tracks are split apart or merged together')\n                    .setOnclick(() => {\n                        data_layer.toggleSplitTracks();\n                        // FIXME: the timeout calls to scale and position (below) cause full ~5 additional re-renders\n                        //  If we can remove these it will greatly speed up re-rendering.\n                        // The key problem here is that the height is apparently not known in advance and is determined after re-render.\n                        if (this.scale_timeout) {\n                            clearTimeout(this.scale_timeout);\n                        }\n                        this.scale_timeout = setTimeout(() => {\n                            this.parent_panel.scaleHeightToData();\n                            this.parent_plot.positionPanels();\n                        }, 0);\n                        this.update();\n                    });\n                return this.update();\n            }\n        }\n    }\n\n\n    /**\n     * (**extension**) Convert a value \"\"rr,gg,bb\" (if given) to a css-friendly color string: \"rgb(rr,gg,bb)\".\n     * This is tailored specifically to the color specification format embraced by the BED file standard.\n     * @alias module:LocusZoom_ScaleFunctions~to_rgb\n     * @param {Object} parameters This function has no defined configuration options\n     * @param {String|null} value The value to convert to rgb\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    function to_rgb(parameters, value) {\n        return value ? `rgb(${value})` : null;\n    }\n\n    const default_layout = {\n        start_field: 'start',\n        end_field: 'end',\n        track_label_field: 'state_name', // Used to label items on the y-axis\n        // Used to uniquely identify tracks for coloring. This tends to lead to more stable coloring/sorting\n        //  than using the label field- eg, state_ids allow us to set global colors across the entire dataset,\n        //  not just choose unique colors within a particular narrow region. (where changing region might lead to more\n        //  categories and different colors)\n        track_split_field: 'state_id',\n        track_split_order: 'DESC',\n        track_split_legend_to_y_axis: 2,\n        split_tracks: true,\n        track_height: 15,\n        track_vertical_spacing: 3,\n        bounding_box_padding: 2,\n        always_hide_legend: false,\n        color: '#B8B8B8',\n        fill_opacity: 1,\n        tooltip_positioning: 'vertical',\n    };\n\n    const BaseLayer = LocusZoom.DataLayers.get('BaseDataLayer');\n\n    /**\n     * (**extension**) Implements a data layer that will render interval annotation tracks (intervals must provide start and end values)\n     * Each interval (such as from a BED file) will be rendered as a rectangle. All spans can be rendered on the same\n     *  row, or each (auto-detected) category can be rendered as one row per category.\n     *\n     * This layer is intended to work with a variety of datasets with special requirements. As such, it has a lot\n     *  of configuration options devoted to identifying how to fill in missing information (such as color)\n     *\n     * @alias module:LocusZoom_DataLayers~intervals\n     * @see module:LocusZoom_DataLayers~BaseDataLayer\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    class LzIntervalsTrack extends BaseLayer {\n        /**\n         * @param {string} [layout.start_field='start'] The field that defines interval start position\n         * @param {string} [layout.end_field='end'] The field that defines interval end position\n         * @param {string} [layout.track_label_field='state_name'] Used to label items on the y-axis\n         * @param {string} [layout.track_split_field='state_id'] Used to define categories on the y-axis. It is usually most convenient to use\n         *  the same value for state_field and label_field (eg 1:1 correspondence).\n         * @param {*|'DESC'} [layout.track_split_order='DESC'] When in split tracks mode, should categories be shown in\n         *  the order given, or descending order\n         * @param {number} [layout.track_split_legend_to_y_axis=2]\n         * @param {boolean} [layout.split_tracks=true] Whether to show tracks as merged (one row) or split (many rows)\n         *  on initial render.\n         * @param {number} [layout.track_height=15] The height of each interval rectangle, in px\n         * @param {number} [layout.track_vertical_spacing=3]\n         * @param {number} [layout.bounding_box_padding=2]\n         * @param {boolean} [layout.always_hide_legend=false] Normally the legend is shown in merged mode and hidden\n         *  in split mode. For datasets with a very large number of categories, it may make sense to hide the legend at all times.\n         * @param {string|module:LocusZoom_DataLayers~ScalableParameter[]} [layout.color='#B8B8B8'] The color of each datum rectangle\n         * @param {number|module:LocusZoom_DataLayers~ScalableParameter[]} [layout.fill_opacity=1]\n         * @param {string} [layout.tooltip_positioning='vertical']\n         */\n        constructor(layout) {\n            LocusZoom.Layouts.merge(layout, default_layout);\n            super(...arguments);\n            this._previous_categories = [];\n            this._categories = [];\n        }\n\n        initialize() {\n            super.initialize();\n            this._statusnodes_group = this.svg.group.append('g')\n                .attr('class', 'lz-data-layer-intervals lz-data-layer-intervals-statusnode');\n            this._datanodes_group = this.svg.group.append('g')\n                .attr('class', 'lz-data_layer-intervals');\n        }\n\n        /**\n         * Split data into tracks such that anything with a common grouping field is in the same track\n         * @param data\n         * @return {unknown[]}\n         * @private\n         */\n        _arrangeTrackSplit(data) {\n            const {track_split_field} = this.layout;\n            const result = {};\n            data.forEach((item) => {\n                const item_key = item[track_split_field];\n                if (!Object.prototype.hasOwnProperty.call(result, item_key)) {\n                    result[item_key] = [];\n                }\n                result[item_key].push(item);\n            });\n            return result;\n        }\n\n        /**\n         * Split data into rows using a simple greedy algorithm such that no two items overlap (share same interval)\n         * Assumes that the data are sorted so item1.start always <= item2.start.\n         *\n         * This function can also simply return all data on a single row. This functionality may become configurable\n         *  in the future but for now reflects a lack of clarity in the requirements/spec. The code to split\n         *  overlapping items is present but may not see direct use.\n         */\n        _arrangeTracksLinear(data, allow_overlap = true) {\n            if (allow_overlap) {\n                // If overlap is allowed, then all the data can live on a single row\n                return [data];\n            }\n\n            // ASSUMPTION: Data is given to us already sorted by start position to facilitate grouping.\n            // We do not sort here because JS \"sort\" is not stable- if there are many intervals that overlap, then we\n            //   can get different layouts (number/order of rows) on each call to \"render\".\n            //\n            // At present, we decide how to update the y-axis based on whether current and former number of rows are\n            //  the same. An unstable sort leads to layout thrashing/too many re-renders. FIXME: don't rely on counts\n            const {start_field, end_field} = this.layout;\n\n            const grouped_data = [[]]; // Prevent two items from colliding by rendering them to different rows, like genes\n            data.forEach((item, index) => {\n                for (let i = 0; i < grouped_data.length; i++) {\n                    // Iterate over all rows of the\n                    const row_to_test = grouped_data[i];\n                    const last_item = row_to_test[row_to_test.length - 1];\n                    // Some programs report open intervals, eg 0-1,1-2,2-3; these points are not considered to overlap (hence the test isn't \"<=\")\n                    const has_overlap = last_item && (item[start_field] < last_item[end_field]) && (last_item[start_field] < item[end_field]);\n                    if (!has_overlap) {\n                        // If there is no overlap, add item to current row, and move on to the next item\n                        row_to_test.push(item);\n                        return;\n                    }\n                }\n                // If this item would collide on all existing rows, create a new row\n                grouped_data.push([item]);\n            });\n            return grouped_data;\n        }\n\n        /**\n         * Annotate each item with the track number, and return.\n         * @param {Object[]}data\n         * @private\n         * @return [String[], Object[]] Return the categories and the data array\n         */\n        _assignTracks(data) {\n            // Flatten the grouped data.\n            const {x_scale} = this.parent;\n            const {start_field, end_field, bounding_box_padding, track_height} = this.layout;\n\n            const grouped_data = this.layout.split_tracks ? this._arrangeTrackSplit(data) : this._arrangeTracksLinear(data, true);\n            const categories = Object.keys(grouped_data);\n            if (this.layout.track_split_order === 'DESC') {\n                categories.reverse();\n            }\n\n            categories.forEach((key, row_index) => {\n                const row = grouped_data[key];\n                row.forEach((item) => {\n                    item[XCS] = x_scale(item[start_field]);\n                    item[XCE] = x_scale(item[end_field]);\n                    item[YCS] = row_index * this.getTrackHeight() + bounding_box_padding;\n                    item[YCE] = item[YCS] + track_height;\n                    // Store the row ID, so that clicking on a point can find the right status node (big highlight box)\n                    item.track = row_index;\n                });\n            });\n            // We're mutating elements of the original data array as a side effect: the return value here is\n            //  interchangeable with `this.data` for subsequent usages\n            // TODO: Can replace this with array.flat once polyfill support improves\n            return [categories, Object.values(grouped_data).reduce((acc, val) => acc.concat(val), [])];\n        }\n\n        /**\n         * When we are in \"split tracks mode\", it's convenient to wrap all individual annotations with a shared\n         *  highlight box that wraps everything on that row.\n         *\n         * This is done automatically by the \"setElementStatus\" code, if this function returns a non-null value\n         *\n         * To define shared highlighting on the track split field define the status node id override\n         * to generate an ID common to the track when we're actively splitting data out to separate tracks\n         * @override\n         * @returns {String}\n         */\n        getElementStatusNodeId(element) {\n            if (this.layout.split_tracks) {\n                // Data nodes are bound to data objects, but the \"status_nodes\" selection is bound to numeric row IDs\n                const track = typeof element === 'object' ? element.track : element;\n                const base = `${this.getBaseId()}-statusnode-${track}`;\n                return base.replace(/[^\\w]/g, '_');\n            }\n            // In merged tracks mode, there is no separate status node\n            return null;\n        }\n\n        // Helper function to sum layout values to derive total height for a single interval track\n        getTrackHeight() {\n            return this.layout.track_height\n                + this.layout.track_vertical_spacing\n                + (2 * this.layout.bounding_box_padding);\n        }\n\n        // Modify the layout as necessary to ensure that appropriate color, label, and legend options are available\n        // Even when not displayed, the legend is used to generate the y-axis ticks\n        _applyLayoutOptions() {\n            const self = this;\n            const base_layout = this._base_layout;\n            const render_layout = this.layout;\n            const base_color_scale = base_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'categorical_bin';\n            });\n            const color_scale = render_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'categorical_bin';\n            });\n            if (!base_color_scale) {\n                // This can be a placeholder (empty categories & values), but it needs to be there\n                throw new Error('Interval tracks must define a `categorical_bin` color scale');\n            }\n\n            const has_colors = base_color_scale.parameters.categories.length && base_color_scale.parameters.values.length;\n            const has_legend = base_layout.legend && base_layout.legend.length;\n\n            if (!!has_colors ^ !!has_legend) {\n                // Don't allow color OR legend to be set manually. It must be both, or neither.\n                throw new Error('To use a manually specified color scheme, both color and legend options must be set.');\n            }\n\n            // Harvest any information about an explicit color field that should be considered when generating colors\n            const rgb_option = base_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'to_rgb';\n            });\n            const rgb_field = rgb_option && rgb_option.field;\n\n            // Auto-generate legend based on data\n            const known_categories = this._generateCategoriesFromData(this.data, rgb_field); // [id, label, itemRgb] items\n\n            if (!has_colors && !has_legend) {\n                // If no color scheme pre-defined, then make a color scheme that is appropriate and apply to the plot\n                // The legend must match the color scheme. If we generate one, then we must generate both.\n\n                const colors = this._makeColorScheme(known_categories);\n                color_scale.parameters.categories = known_categories.map(function (item) {\n                    return item[0];\n                });\n                color_scale.parameters.values = colors;\n\n                this.layout.legend = known_categories.map(function (pair, index) {\n                    const id = pair[0];\n                    const label = pair[1];\n                    const item_color = color_scale.parameters.values[index];\n                    const item = { shape: 'rect', width: 9, label: label, color: item_color };\n                    item[self.layout.track_split_field] = id;\n                    return item;\n                });\n            }\n        }\n\n        // Implement the main render function\n        render() {\n            //// Autogenerate layout options if not provided\n            this._applyLayoutOptions();\n\n            // Determine the appropriate layout for tracks. Store the previous categories (y axis ticks) to decide\n            //   whether the axis needs to be re-rendered.\n            this._previous_categories = this._categories;\n            const [categories, assigned_data] = this._assignTracks(this.data);\n            this._categories = categories;\n            // Update the legend axis if the number of ticks changed\n            const labels_changed = !categories.every( (item, index) => item === this._previous_categories[index]);\n            if (labels_changed) {\n                this.updateSplitTrackAxis(categories);\n                return;\n            }\n\n            // Apply filters to only render a specified set of points. Hidden fields will still be given space to render, but not shown.\n            const track_data = this._applyFilters(assigned_data);\n\n            // Clear before every render so that, eg, highlighting doesn't persist if we load a region with different\n            //  categories (row 2 might be a different category and it's confusing if the row stays highlighted but changes meaning)\n            // Highlighting will automatically get added back if it actually makes sense, courtesy of setElementStatus,\n            //  if a selected item is still in view after the new region loads.\n            this._statusnodes_group.selectAll('rect')\n                .remove();\n\n            // Reselect in order to add new data\n            const status_nodes = this._statusnodes_group.selectAll('rect')\n                .data(d3.range(categories.length));\n\n            if (this.layout.split_tracks) {\n                // Status nodes: a big highlight box around all items of the same type. Used in split tracks mode,\n                //  because everything on the same row is the same category and a group makes sense\n                // There are no status nodes in merged mode, because the same row contains many kinds of things\n\n                // Status nodes are 1 per row, so \"data\" can just be a dummy list of possible row IDs\n                // Each status node is a box that runs the length of the panel and receives a special \"colored box\" css\n                //  style when selected\n                const height = this.getTrackHeight();\n                status_nodes.enter()\n                    .append('rect')\n                    .attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-shared')\n                    .attr('rx', this.layout.bounding_box_padding)\n                    .attr('ry', this.layout.bounding_box_padding)\n                    .merge(status_nodes)\n                    .attr('id', (d) => this.getElementStatusNodeId(d))\n                    .attr('x', 0)\n                    .attr('y', (d) => (d * height))\n                    .attr('width', this.parent.layout.cliparea.width)\n                    .attr('height', Math.max(height - this.layout.track_vertical_spacing, 1));\n            }\n            status_nodes.exit()\n                .remove();\n\n            // Draw rectangles for the data (intervals)\n            const data_nodes = this._datanodes_group.selectAll('rect')\n                .data(track_data, (d) => d[this.layout.id_field]);\n\n            data_nodes.enter()\n                .append('rect')\n                .merge(data_nodes)\n                .attr('id', (d) => this.getElementId(d))\n                .attr('x', (d) => d[XCS])\n                .attr('y', (d) => d[YCS])\n                .attr('width', (d) => Math.max(d[XCE] - d[XCS], 1))\n                .attr('height', this.layout.track_height)\n                .attr('fill', (d, i) => this.resolveScalableParameter(this.layout.color, d, i))\n                .attr('fill-opacity', (d, i) => this.resolveScalableParameter(this.layout.fill_opacity, d, i));\n\n            data_nodes.exit()\n                .remove();\n\n            this._datanodes_group\n                .call(this.applyBehaviors.bind(this));\n\n            // The intervals track allows legends to be dynamically generated, in which case space can only be\n            //  allocated after the panel has been rendered.\n            if (this.parent && this.parent.legend) {\n                this.parent.legend.render();\n            }\n        }\n\n        _getTooltipPosition(tooltip) {\n            return {\n                x_min: tooltip.data[XCS],\n                x_max: tooltip.data[XCE],\n                y_min: tooltip.data[YCS],\n                y_max: tooltip.data[YCE],\n            };\n        }\n\n        // Redraw split track axis or hide it, and show/hide the legend, as determined\n        // by current layout parameters and data\n        updateSplitTrackAxis(categories) {\n            const legend_axis = this.layout.track_split_legend_to_y_axis ? `y${this.layout.track_split_legend_to_y_axis}` : false;\n            if (this.layout.split_tracks) {\n                const tracks = +categories.length || 0;\n                const track_height = +this.layout.track_height || 0;\n                const track_spacing = 2 * (+this.layout.bounding_box_padding || 0) + (+this.layout.track_vertical_spacing || 0);\n                const target_height = (tracks * track_height) + ((tracks - 1) * track_spacing);\n                this.parent.scaleHeightToData(target_height);\n                if (legend_axis && this.parent.legend) {\n                    this.parent.legend.hide();\n                    this.parent.layout.axes[legend_axis] = {\n                        render: true,\n                        ticks: [],\n                        range: {\n                            start: (target_height - (this.layout.track_height / 2)),\n                            end: (this.layout.track_height / 2),\n                        },\n                    };\n                    // There is a very tight coupling between the display directives: each legend item must identify a key\n                    //  field for unique tracks. (Typically this is `state_id`, the same key field used to assign unique colors)\n                    // The list of unique keys corresponds to the order along the y-axis\n                    this.layout.legend.forEach((element) => {\n                        const key = element[this.layout.track_split_field];\n                        let track = categories.findIndex((item) => item === key);\n                        if (track !== -1) {\n                            if (this.layout.track_split_order === 'DESC') {\n                                track = Math.abs(track - tracks - 1);\n                            }\n                            this.parent.layout.axes[legend_axis].ticks.push({\n                                y: track - 1,\n                                text: element.label,\n                            });\n                        }\n                    });\n                    this.layout.y_axis = {\n                        axis: this.layout.track_split_legend_to_y_axis,\n                        floor: 1,\n                        ceiling: tracks,\n                    };\n                }\n                // This will trigger a re-render\n                this.parent_plot.positionPanels();\n            } else {\n                if (legend_axis && this.parent.legend) {\n                    if (!this.layout.always_hide_legend) {\n                        this.parent.legend.show();\n                    }\n                    this.parent.layout.axes[legend_axis] = { render: false };\n                    this.parent.render();\n                }\n            }\n            return this;\n        }\n\n        // Method to not only toggle the split tracks boolean but also update\n        // necessary display values to animate a complete merge/split\n        toggleSplitTracks() {\n            this.layout.split_tracks = !this.layout.split_tracks;\n            if (this.parent.legend && !this.layout.always_hide_legend) {\n                this.parent.layout.margin.bottom = 5 + (this.layout.split_tracks ? 0 : this.parent.legend.layout.height + 5);\n            }\n            this.render();\n            return this;\n        }\n\n        // Choose an appropriate color scheme based on the number of items in the track, and whether or not we are\n        //  using explicitly provided itemRgb information\n        _makeColorScheme(category_info) {\n            // If at least one element has an explicit itemRgb, assume the entire dataset has colors. BED intervals require rgb triplets,so assume that colors will always be \"r,g,b\" format.\n            const has_explicit_colors = category_info.find((item) => item[2]);\n            if (has_explicit_colors) {\n                return category_info.map((item) => to_rgb({}, item[2]));\n            }\n\n            // Use a set of color schemes for common 15, 18, or 25 state models, as specified from:\n            //  https://egg2.wustl.edu/roadmap/web_portal/chr_state_learning.html\n            // These are actually reversed so that dim colors come first, on the premise that usually these are the\n            //  most common states\n            const n_categories = category_info.length;\n            if (n_categories <= 15) {\n                return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(233,150,122)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(50,205,50)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            } else if (n_categories <= 18) {\n                return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            } else {\n                // If there are more than 25 categories, the interval layer will fall back to the 'null value' option\n                return ['rgb(212,212,212)', 'rgb(128,128,128)', 'rgb(112,48,160)', 'rgb(230,184,183)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,102)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,150,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            }\n        }\n\n        /**\n         * Find all of the unique tracks (a combination of name and ID information)\n         * @param {Object} data\n         * @param {String} [rgb_field] A field that contains an RGB value. Aimed at BED files with an itemRgb column\n         * @private\n         * @returns {Array} All [unique_id, label, color] pairs in data. The unique_id is the thing used to define groupings\n         *  most unambiguously.\n         */\n        _generateCategoriesFromData(data, rgb_field) {\n            const self = this;\n            // Use the hard-coded legend if available (ignoring any mods on re-render)\n            const legend = this._base_layout.legend;\n            if (legend && legend.length) {\n                return legend.map((item) => [item[this.layout.track_split_field], item.label, item.color]);\n            }\n\n            // Generate options from data, if no preset legend exists\n            const unique_ids = {}; // make categories unique\n            const categories = [];\n\n            data.forEach((item) => {\n                const id = item[self.layout.track_split_field];\n                if (!Object.prototype.hasOwnProperty.call(unique_ids, id)) {\n                    unique_ids[id] = null;\n                    // If rgbfield is null, then the last entry is undefined/null as well\n                    categories.push([id, item[this.layout.track_label_field], item[rgb_field]]);\n                }\n            });\n            return categories;\n        }\n    }\n\n    /**\n     * (**extension**) A basic tooltip with information to be shown over an intervals datum\n     * @alias module:LocusZoom_Layouts~standard_intervals\n     * @type tooltip\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    const intervals_tooltip_layout = {\n        closable: false,\n        show: { or: ['highlighted', 'selected'] },\n        hide: { and: ['unhighlighted', 'unselected'] },\n        html: '{{intervals:state_name|htmlescape}}<br>{{intervals:start|htmlescape}}-{{intervals:end|htmlescape}}',\n    };\n\n    /**\n     * (**extension**) A data layer with some preconfigured options for intervals display. This example was designed for chromHMM output,\n     *   in which various states are assigned numeric state IDs and (<= as many) text state names.\n     *\n     *  This layout is deprecated; most usages would be better served by the bed_intervals_layer layout instead.\n     * @alias module:LocusZoom_Layouts~intervals_layer\n     * @type data_layer\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    const intervals_layer_layout =  {\n        namespace: { 'intervals': 'intervals' },\n        id: 'intervals',\n        type: 'intervals',\n        tag: 'intervals',\n        id_field: '{{intervals:start}}_{{intervals:end}}_{{intervals:state_name}}',\n        start_field: 'intervals:start',\n        end_field: 'intervals:end',\n        track_split_field: 'intervals:state_name',\n        track_label_field: 'intervals:state_name',\n        split_tracks: false,\n        always_hide_legend: true,\n        color: [\n            {\n                // If present, an explicit color field will override any other option (and be used to auto-generate legend)\n                field: 'intervals:itemRgb',\n                scale_function: 'to_rgb',\n            },\n            {\n                // TODO: Consider changing this to stable_choice in the future, for more stable coloring\n                field: 'intervals:state_name',\n                scale_function: 'categorical_bin',\n                parameters: {\n                    // Placeholder. Empty categories and values will automatically be filled in when new data loads.\n                    categories: [],\n                    values: [],\n                    null_value: '#B8B8B8',\n                },\n            },\n        ],\n        legend: [], // Placeholder; auto-filled when data loads.\n        behaviors: {\n            onmouseover: [\n                { action: 'set', status: 'highlighted' },\n            ],\n            onmouseout: [\n                { action: 'unset', status: 'highlighted' },\n            ],\n            onclick: [\n                { action: 'toggle', status: 'selected', exclusive: true },\n            ],\n            onshiftclick: [\n                { action: 'toggle', status: 'selected' },\n            ],\n        },\n        tooltip: intervals_tooltip_layout,\n    };\n\n\n    /**\n     * (**extension**) A data layer with some preconfigured options for intervals display. This example was designed for standard BED3+ files and the field names emitted by the LzParsers extension.\n     * @alias module:LocusZoom_Layouts~bed_intervals_layer\n     * @type data_layer\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    const bed_intervals_layer_layout = LocusZoom.Layouts.merge({\n        id_field: '{{intervals:chromStart}}_{{intervals:chromEnd}}_{{intervals:name}}',\n        start_field: 'intervals:chromStart',\n        end_field: 'intervals:chromEnd',\n        track_split_field: 'intervals:name',\n        track_label_field: 'intervals:name',\n        split_tracks: true,\n        always_hide_legend: false,\n        color: [\n            {\n                // If present, an explicit color field will override any other option (and be used to auto-generate legend)\n                field: 'intervals:itemRgb',\n                scale_function: 'to_rgb',\n            },\n            {\n                // TODO: Consider changing this to stable_choice in the future, for more stable coloring\n                field: 'intervals:name',\n                scale_function: 'categorical_bin',\n                parameters: {\n                    // Placeholder. Empty categories and values will automatically be filled in when new data loads.\n                    categories: [],\n                    values: [],\n                    null_value: '#B8B8B8',\n                },\n            },\n        ],\n        tooltip: LocusZoom.Layouts.merge({\n            html: `<strong>Group: </strong>{{intervals:name|htmlescape}}<br>\n<strong>Region: </strong>{{intervals:chromStart|htmlescape}}-{{intervals:chromEnd|htmlescape}}\n{{#if intervals:score}}<br>\n<strong>Score:</strong> {{intervals:score|htmlescape}}{{/if}}`,\n        }, intervals_tooltip_layout),\n    }, intervals_layer_layout);\n\n\n    /**\n     * (**extension**) A panel containing an intervals data layer, eg for BED tracks. This is a legacy layout whose field names were specific to one partner site.\n     * @alias module:LocusZoom_Layouts~intervals\n     * @type panel\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    const intervals_panel_layout = {\n        id: 'intervals',\n        tag: 'intervals',\n        min_height: 50,\n        height: 50,\n        margin: { top: 25, right: 150, bottom: 5, left: 70 },\n        toolbar: (function () {\n            const l = LocusZoom.Layouts.get('toolbar', 'standard_panel');\n            l.widgets.push({\n                type: 'toggle_split_tracks',\n                data_layer_id: 'intervals',\n                position: 'right',\n            });\n            return l;\n        })(),\n        axes: {},\n        interaction: {\n            drag_background_to_pan: true,\n            scroll_to_zoom: true,\n            x_linked: true,\n        },\n        legend: {\n            hidden: true,\n            orientation: 'horizontal',\n            origin: { x: 50, y: 0 },\n            pad_from_bottom: 5,\n        },\n        data_layers: [intervals_layer_layout],\n    };\n\n    /**\n     * (**extension**) A panel containing an intervals data layer, eg for BED tracks. These field names match those returned by the LzParsers extension.\n     * @alias module:LocusZoom_Layouts~bed_intervals\n     * @type panel\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    const bed_intervals_panel_layout = LocusZoom.Layouts.merge({\n        // Normal BED tracks show the panel legend in collapsed mode!\n        min_height: 120,\n        height: 120,\n        data_layers: [bed_intervals_layer_layout],\n    }, intervals_panel_layout);\n\n    /**\n     * (**extension**) A plot layout that shows association summary statistics, genes, and interval data. This example assumes\n     *  chromHMM data. (see panel layout) Few people will use the full intervals plot layout directly outside of an example.\n     * @alias module:LocusZoom_Layouts~interval_association\n     * @type plot\n     * @see {@link module:ext/lz-intervals-track} for required extension and installation instructions\n     */\n    const intervals_plot_layout = {\n        state: {},\n        width: 800,\n        responsive_resize: true,\n        min_region_scale: 20000,\n        max_region_scale: 1000000,\n        toolbar: LocusZoom.Layouts.get('toolbar', 'standard_association'),\n        panels: [\n            LocusZoom.Layouts.get('panel', 'association'),\n            LocusZoom.Layouts.merge({ min_height: 120, height: 120 }, intervals_panel_layout),\n            LocusZoom.Layouts.get('panel', 'genes'),\n        ],\n    };\n\n    LocusZoom.Adapters.add('IntervalLZ', IntervalLZ);\n    LocusZoom.DataLayers.add('intervals', LzIntervalsTrack);\n\n    LocusZoom.Layouts.add('tooltip', 'standard_intervals', intervals_tooltip_layout);\n    LocusZoom.Layouts.add('data_layer', 'intervals', intervals_layer_layout);\n    LocusZoom.Layouts.add('data_layer', 'bed_intervals', bed_intervals_layer_layout);\n    LocusZoom.Layouts.add('panel', 'intervals', intervals_panel_layout);\n    LocusZoom.Layouts.add('panel', 'bed_intervals', bed_intervals_panel_layout);\n    LocusZoom.Layouts.add('plot', 'interval_association', intervals_plot_layout);\n\n    LocusZoom.ScaleFunctions.add('to_rgb', to_rgb);\n\n    LocusZoom.Widgets.add('toggle_split_tracks', ToggleSplitTracks);\n}\n\nif (typeof LocusZoom !== 'undefined') {\n    // Auto-register the plugin when included as a script tag. ES6 module users must register via LocusZoom.use()\n    // eslint-disable-next-line no-undef\n    LocusZoom.use(install);\n}\n\n\nexport default install;\n"],"sourceRoot":""}