{"version":3,"sources":["webpack://[name]/webpack/bootstrap","webpack://[name]/webpack/runtime/define property getters","webpack://[name]/webpack/runtime/hasOwnProperty shorthand","webpack://[name]/external \"raremetal\"","webpack://[name]/./esm/ext/lz-aggregation-tests.js"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","raremetal","install","LocusZoom","BaseUrlAdapter","Adapters","DataFunctions","add","state","genes_data","aggregation_data","groupedAggregation","groups","forEach","result","group","push","pvalue","gene","gene_id","gene_name","tests","aggregation_best_pvalue","Math","min","apply","config","prefix_namespace","super","aggregation_tests","genoset_id","genoset_build","phenoset_build","pheno","calcs","masks","mask_ids","map","item","name","options","this","_url","chr","start","end","phenoset_id","JSON","stringify","chrom","stop","genotypeDataset","phenotypeDataset","phenotype","samples","genomeBuild","url","_getURL","body","_getCacheKey","fetch","method","headers","then","response","ok","Error","statusText","text","resp","json","parse","error","data","records","variants","filter","groupType","parsed","helpers","byMask","keys","length","results","toJSON","res","mask_id_to_desc","reduce","acc","val","description","mask_name","mask","catch","e","console","agg_results","_agg_results","Promise","resolve","REGEX_EPACTS","RegExp","variant","altFreq","match","_","chromosome","position","ref_allele","ref_allele_freq","log_pvalue","log10","sort","a","b","use"],"mappings":"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","file":"ext/lz-aggregation-tests.min.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const __WEBPACK_NAMESPACE_OBJECT__ = raremetal;","/**\n * LocusZoom extensions used to calculate and render aggregation test results. Because these calculations depend on an\n *   external library, the special data adapters are defined here, rather than in LocusZoom core code.\n *\n * This extension provides a number of features that are closely tied to the aggregation tests demo,\n *  and thus the specific UI and data operations are less of a drop-in generic addon than most other extensions.\n *  This tool also depends on a calculation tool (like RAREMETAL-server) with access to sample specific genotypes.\n *\n * ### Loading and usage\n * The page must incorporate and load all libraries before this file can be used, including:\n *    - LocusZoom\n *    - raremetal.js (available via NPM or a related CDN)\n *\n * To use in an environment without special JS build tooling, simply load the extension file as JS from a CDN (after any dependencies):\n * ```\n * <script src=\"https://cdn.jsdelivr.net/npm/locuszoom@INSERT_VERSION_HERE/dist/ext/lz-aggregation-tests.min.js\" type=\"application/javascript\"></script>\n * ```\n *\n * To use with ES6 modules, the plugin must be loaded and registered explicitly before use:\n * ```\n * import LocusZoom from 'locuszoom';\n * import aggTests from 'locuszoom/esm/ext/lz-aggregation-tests';\n * LocusZoom.use(aggTests);\n * ```\n *\n * Then use the layouts and data adapters made available by this extension. (see demos and documentation for guidance)\n * @private\n * @module\n */\n// This is defined as a UMD module, to work with multiple different module systems / bundlers\n// Arcane build note: everything defined here gets registered globally. This is not a \"pure\" module, and some build\n//  systems may require being told that this file has side effects.\n\nimport {helpers} from 'raremetal.js';\n\nfunction install (LocusZoom) {\n    const BaseUrlAdapter = LocusZoom.Adapters.get('BaseLZAdapter');\n\n    /**\n     * Calculates gene or region-based tests based on provided data, using the raremetal.js library.\n     *   It will rarely be used by itself, but rather using a connector that attaches the results to data from\n     *   another source (like genes). Using a separate connector allows us to add caching and run this front-end\n     *   calculation only once, while using it in many different places.\n     * @see module:ext/lz-aggregation-tests\n     * @private\n     */\n    class AggregationTestSourceLZ extends BaseUrlAdapter {\n        constructor(config) {\n            config.prefix_namespace = false;\n            super(config);\n        }\n\n        _buildRequestOptions(state) {\n            const { aggregation_tests = {} } = state;\n            const {\n                // eslint-disable-next-line no-unused-vars\n                genoset_id = null, genoset_build = null, phenoset_build = null, pheno = null, calcs = {}, masks = [],\n            } = aggregation_tests;\n\n            aggregation_tests.mask_ids = masks.map((item) => item.name);\n            // Many of these params will be undefined if no tests defined\n            state.aggregation_tests = aggregation_tests;\n            return state;\n        }\n\n        _getURL(options) {\n            // Unlike most sources, calculations may require access to plot state data even after the initial request\n            // This example source REQUIRES that the external UI widget would store the needed test definitions in a plot state\n            //  field called `aggregation_tests` (an object {masks: [], calcs: {})\n            return this._url;\n        }\n\n        _getCacheKey(options) {\n            const { chr, start, end, aggregation_tests } = options;\n            const { genoset_id = null, genoset_build = null, phenoset_id = null, pheno = null, mask_ids } = aggregation_tests;\n\n            return JSON.stringify({\n                chrom: chr,\n                start: start,\n                stop: end,\n                genotypeDataset: genoset_id,\n                phenotypeDataset: phenoset_id,\n                phenotype: pheno,\n                samples: 'ALL',\n                genomeBuild: genoset_build,\n                masks: mask_ids,\n            });\n        }\n\n        _performRequest(options) {\n            const url = this._getURL(options);\n            const body = this._getCacheKey(options);  // cache key doubles as request body\n            const headers = {\n                'Content-Type': 'application/json',\n            };\n\n            return fetch(url, {method: 'POST', body: body, headers: headers})\n                .then((response) => {\n                    if (!response.ok) {\n                        throw new Error(response.statusText);\n                    }\n                    return response.text();\n                }).then((resp) => {\n                    const json = typeof resp == 'string' ? JSON.parse(resp) : resp;\n                    if (json.error) {\n                        // RAREMETAL-server quirk: The API sometimes returns a 200 status code for failed requests,\n                        //    with a human-readable error description as a key\n                        // For now, this should be treated strictly as an error\n                        throw new Error(json.error);\n                    }\n                    return json.data;\n                });\n        }\n\n        _annotateRecords(records, options) {\n            // The server response gives covariance for a set of masks, but the actual calculations are done separately.\n            //   Eg, several types of aggtests might use the same covariance matrix.\n\n            // TODO In practice, the test calculations are slow. Investigate caching full results (returning all from performRequest), not just covmat.\n            // This code is largely for demonstration purposes and does not reflect modern best practices possible in LocusZoom (eg sources + dependencies to link together requests)\n            const { aggregation_tests } = options;\n            const { calcs = [], mask_ids = [], masks = [] } = aggregation_tests;\n\n            // In a page using live API data, the UI would only request the masks it needs from the API.\n            // But in our demos, sometimes boilerplate JSON has more masks than the UI asked for. Limit what calcs we run (by\n            //  type, and to the set of groups requested by the user)\n\n            // The Raremetal-server API has a quirk: it returns a different payload structure if no groups are defined\n            //  for the request region. Detect when that happens and end the calculation immediately in that case\n            if (!records.groups) {\n                return { groups: [], variants: [] };\n            }\n\n            records.groups = records.groups.filter((item) => item.groupType === 'GENE');\n\n            const parsed = helpers.parsePortalJSON(records);\n            let groups = parsed[0];\n            const variants = parsed[1];\n            // Some APIs may return more data than we want (eg simple sites that are just serving up premade scorecov json files).\n            //  Filter the response to just what the user has chosen to analyze.\n            groups = groups.byMask(mask_ids);\n\n            // Determine what calculations to run\n            if (!calcs || Object.keys(calcs).length === 0) {\n                // If no calcs have been requested, then return a dummy placeholder immediately\n                return { variants: [], groups: [], results: [] };\n            }\n            const runner = new helpers.PortalTestRunner(groups, variants, calcs);\n\n            return runner.toJSON()\n                .then(function (res) {\n                    // Internally, raremetal helpers track how the calculation is done, but not any display-friendly values\n                    // We will annotate each mask name (id) with a human-friendly description for later use\n                    const mask_id_to_desc = masks.reduce((acc, val) => {\n                        acc[val.name] = val.description;\n                        return acc;\n                    }, {});\n                    res.data.groups.forEach((group) => {\n                        group.mask_name = mask_id_to_desc[group.mask];\n                    });\n                    return res.data;\n                })\n                .catch(function (e) {\n                    console.error(e);\n                    throw new Error('Failed to calculate aggregation test results');\n                });\n        }\n    }\n\n    /**\n     * Restructure RAREMETAL-SERVER data used to calculate aggregation tests into a format that can be used to\n     *  display a GWAS scatter plot.\n     * @see module:ext/lz-aggregation-tests\n     * @see module:LocusZoom_Adapters\n     * @private\n     */\n    class AssocFromAggregationLZ extends BaseUrlAdapter {\n        _buildRequestOptions(state, agg_results) {\n            // This adapter just reformats an existing payload from cache (maybe this is better as a data_operation instead of an adapter nowadays?)\n            if (!agg_results) {\n                throw new Error('Aggregation test results must be provided');\n            }\n            state._agg_results = agg_results;\n            return state;\n        }\n\n        _performRequest(options) {\n            return Promise.resolve(options._agg_results['variants']);\n        }\n\n        _normalizeResponse(data) {\n            // The payload structure of the association source is slightly different than the one required by association\n            //   plots. For example, we need to parse variant names and convert to log_pvalue\n            const REGEX_EPACTS = new RegExp('(?:chr)?(.+):(\\\\d+)_?(\\\\w+)?/?([^_]+)?_?(.*)?');  // match API variant strings\n            return data.map((item) => {\n                const { variant, altFreq, pvalue } = item;\n                const match = variant.match(REGEX_EPACTS);\n                const [_, chromosome, position, ref_allele] = match;\n                return {\n                    variant: variant,\n                    chromosome,\n                    position: +position,\n                    ref_allele,\n                    ref_allele_freq: 1 - altFreq,\n                    log_pvalue: -Math.log10(pvalue),\n                };\n            }).sort((a, b) => {\n                a = a.variant;\n                b = b.variant;\n                if (a < b) {\n                    return -1;\n                } else if (a > b) {\n                    return 1;\n                } else {\n                    // names must be equal\n                    return 0;\n                }\n            });\n        }\n    }\n\n    const genes_plus_aggregation = (state, [genes_data, aggregation_data]) => {\n        // Used to highlight genes with significant aggtest results. Unlike a basic left join, it chooses one specific aggtest with the most significant results\n\n        // Tie the calculated group-test results to genes with a matching name\n        const groupedAggregation = {};  // Group together all tests done on that gene- any mask, any test\n\n        aggregation_data.groups.forEach(function (result) {\n            if (!Object.prototype.hasOwnProperty.call(groupedAggregation, result.group)) {\n                groupedAggregation[result.group] = [];\n            }\n            groupedAggregation[result.group].push(result.pvalue);\n        });\n\n        // Annotate any genes that have test results\n        genes_data.forEach((gene) => {\n            const gene_id = gene.gene_name;\n            const tests = groupedAggregation[gene_id];\n            if (tests) {\n                gene.aggregation_best_pvalue = Math.min.apply(null, tests);\n            }\n        });\n        return genes_data;\n    };\n    LocusZoom.DataFunctions.add('gene_plus_aggregation', genes_plus_aggregation);\n\n    LocusZoom.Adapters.add('AggregationTestSourceLZ', AggregationTestSourceLZ);\n    LocusZoom.Adapters.add('AssocFromAggregationLZ', AssocFromAggregationLZ);\n}\n\n\nif (typeof LocusZoom !== 'undefined') {\n    // Auto-register the plugin when included as a script tag. ES6 module users must register via LocusZoom.use()\n    // eslint-disable-next-line no-undef\n    LocusZoom.use(install);\n}\n\n\nexport default install;\n"],"sourceRoot":""}