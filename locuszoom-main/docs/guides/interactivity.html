<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Mechanisms for Interactivity</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../css/pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Mechanisms for Interactivity</h1>
</header>
<nav id="TOC" role="doc-toc">
<h2 id="toc-title">Table of Contents</h2>
<ul>
<li><a href="#communication-with-the-outside-world">Communication with the outside world</a>
<ul>
<li><a href="#who-controls-the-data-push-vs-pull">Who controls the data? (push vs pull)</a>
<ul>
<li><a href="#what-is-remembered">What is remembered?</a></li>
</ul></li>
<li><a href="#using-external-commands-to-update-the-plot">Using external commands to update the plot</a>
<ul>
<li><a href="#not-all-data-operations-happen-on-the-server">Not all data operations happen on the server</a></li>
</ul></li>
<li><a href="#maintaining-consistency">Maintaining consistency</a></li>
</ul></li>
<li><a href="#primitives-underlying-mechanisms">Primitives: Underlying mechanisms</a>
<ul>
<li><a href="#layout-mutations-change-what-gets-rendered">Layout mutations change what gets rendered</a>
<ul>
<li><a href="#helper-functions-for-modifying-nested-layouts">Helper functions for modifying nested layouts</a></li>
</ul></li>
<li><a href="#events-communicate-with-the-outside-world">Events communicate with the outside world</a></li>
<li><a href="#share-data-with-other-widgets-via-subscribetodata">Share data with other widgets via <code>subscribeToData</code></a>
<ul>
<li><a href="#advanced-alternative">Advanced alternative</a></li>
</ul></li>
<li><a href="#filters-control-what-is-shown">Filters control what is shown</a>
<ul>
<li><a href="#adding-your-own-custom-filter">Adding your own custom filter</a></li>
<li><a href="#filters-can-transform-the-value-before-comparing">Filters can transform the value before comparing</a></li>
</ul></li>
<li><a href="#annotations-preserve-custom-options-across-re-render">Annotations preserve custom options across re-render</a></li>
<li><a href="#matching-similar-elements-across-panels">Matching similar elements across panels</a>
<ul>
<li><a href="#matching-rules-can-be-customized">Matching rules can be customized</a></li>
<li><a href="#you-cannot-be-more-clever-than-your-underlying-data">You cannot be more clever than your underlying data</a></li>
</ul></li>
</ul></li>
<li><a href="#built-in-features-to-simplify-interactivity">Built-in features to simplify interactivity</a>
<ul>
<li><a href="#tooltips">Tooltips</a></li>
<li><a href="#behaviors">Behaviors</a></li>
<li><a href="#toolbar-widgets">Toolbar Widgets</a>
<ul>
<li><a href="#toggle-between-render-modes-with-display_options">Toggle between render modes with display_options</a></li>
<li><a href="#modify-data-retrieval-via-set_state">Modify data retrieval via set_state</a></li>
<li><a href="#control-what-is-shown-with-filter_field">Control what is shown with filter_field</a></li>
</ul></li>
<li><a href="#extensions">Extensions</a>
<ul>
<li><a href="#create-shareable-region-links-with-dynamicurls">Create shareable region links with DynamicUrls</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<p>Traditionally, LocusZoom visualizations are designed to serve as artifacts for publication. These tend to be static images, in which information is conveyed via visual qualities such as color, size, shape, and position.</p>
<p>With the advent of LocusZoom.js in the web browser, an additional dimension was added: <em>time</em>. Interactivity allows the user to toggle between two different views, and very quickly see how results are changed (eg different LD populations, before/after a calculation, etc). Responding to user-initiated events in real time also makes it possible to filter which results are shown, based on user-provided criteria (“significant pvalues”) or matching behavior (“find similar items in other panels”).</p>
<p>Another benefit of working in the web browser is that data can be dynamically connected to other representations: for example, an HTML table can be updated to always use the same data shown in the plot.</p>
<blockquote>
<p><em>WARNING:</em> This guide covers some of the most advanced mechanisms in LocusZoom, and assumes a strong knowledge of other features such as layouts, namespaces, and data adapters.</p>
</blockquote>
<h1 id="communication-with-the-outside-world">Communication with the outside world</h1>
<h2 id="who-controls-the-data-push-vs-pull">Who controls the data? (push vs pull)</h2>
<p>A LocusZoom.js plot allows the user to pan and zoom to new regions. In order to update in response to user events, the plot must be able to ask for (pull) the data it needs, rather than render whatever it was given initially (push).</p>
<p>This is a common sticking point when adding LocusZoom to a page with other interactive widgets that share the same data: each widget makes assumptions about the shape of the data, and it can be frustrating to cede control of data requests to any one piece of the page. Trying to force-feed data from outside of the plot (push) often leads to bugs, because the external page and LocusZoom may not agree on what data is to be shown.</p>
<p>Fortunately, there are ways for widgets to cooperate! In the pull-oriented data retrieval model used by LocusZoom, data fetches are represented as a discrete event. Thus it is possible to recognize when the plot changes, and broadcast updates to other widgets accordingly. We provide several mechanisms (such as <code>plot.subscribeToData</code>) to make this possible.</p>
<h3 id="what-is-remembered">What is remembered?</h3>
<p>Each time the plot is re-rendered, LocusZoom.js determines what data should be shown. Client-side features like filters and matching apply after the network request is complete: thus the data is recalculated even if the user is viewing the same region.</p>
<p>Because LocusZoom pulls in its data, very little state is preserved within the rendering layer when the plot is redrawn. Outside of a few selected mechanisms (eg display annotations), changes to data (like calculated fields) should be added in the data adapter, not in the rendering layer.</p>
<blockquote>
<p>Tip: <em>Do not</em> try to force display changes by mutating <code>data_layer.data</code> directly: the changes would be overwritten on the next re-render.</p>
<p>The best way to create a bug free page is to use mechanisms that cooperate with the data flow, rather than trying to impose a different model imperatively from the outside.</p>
</blockquote>
<p><em>See also</em>:</p>
<ul>
<li>Adding custom fields while fetching data: <code>BaseApiAdapter.annotateData</code></li>
<li>Adding interactive rendering hints such as “show a label for this point”: <code>BaseDataLayer.setElementAnnotation</code></li>
</ul>
<h2 id="using-external-commands-to-update-the-plot">Using external commands to update the plot</h2>
<p>There are many times when it would be advantageous to alter the plot in response to external events. For example: the user might define aggregation tests based on a set of variants, then update the plot with the results of the calculation.</p>
<p>The most common mechanism for this to happen is to provide the new information as parameters in global <em>state</em> : <code>plot.applyState({option1: value1})</code>. The <em>state</em> is accessible to all data adapters, and can thus be used to modify the data requested. At the end of <code>applyState</code>, the plot is automatically re-rendered to reflect the new information.</p>
<p>This is a surprisingly common operation. For example, to change the genetic region shown in the plot, we often write the following code: <code>plot.applyState({chr:'1', start: 100, end: 500})</code></p>
<p>It is also possible to call <code>plot.applyState()</code> without arguments, and the plot will still re-render as needed. This is used with techniques like layout mutations (below): something about the plot is changed, and then the plot is re-rendered.</p>
<h3 id="not-all-data-operations-happen-on-the-server">Not all data operations happen on the server</h3>
<p>Although <em>state</em> can be used to influence how a network request is performed, this is by no means the only option. For example, a data source could be written to perform a calculation (rather than a network request), and the state parameters could contain inputs that affect how the calculation is run.</p>
<h2 id="maintaining-consistency">Maintaining consistency</h2>
<p>When using a LocusZoom plot to communicate with other parts of the page, it is a good idea to practice separation of concerns. This means allowing LocusZoom to handle its own internals, and using the provided mechanisms (like events) to understand when changes occur.</p>
<p>For example, consider a LocusZoom plot that shows two datasets as stacked panels, on a page with an external “dataset picker” that showed which tracks were added. A user could remove one track by clicking either the “dataset picker” (outside LocusZoom) or the “remove panel” button (inside LocusZoom): either way, the dataset picker should always accurately reflect whether or not the panel is really being shown.</p>
<p>Rather than tracking the list of shown panels in two places, use provided LocusZoom events (like <code>panel_removed</code>) to respond to events that could be initiated from within the plot. Thus, LocusZoom can communicate changes to the outside world, and both widgets can accurately reflect what the user sees.</p>
<blockquote>
<p>Currently, there is no <code>panel_added</code> event in LocusZoom, because at present this action cannot be initiated from a user action within the plot. The list of events is not exhaustive, but efforts are made to reflect scenarios where communication is useful.</p>
</blockquote>
<h1 id="primitives-underlying-mechanisms">Primitives: Underlying mechanisms</h1>
<p>In order to allow interactivity, LocusZoom.js provides a few common mechanisms for operating on data. These mechanisms can be combined into more powerful forms.</p>
<h2 id="layout-mutations-change-what-gets-rendered">Layout mutations change what gets rendered</h2>
<p>Each LocusZoom rendering is controlled by a declarative set of layout options. In practice, this means that a clever developer can change key options (eg point color, or what field is shown on the y-axis) simply by modifying (mutating) the layout, then re-rendering.</p>
<p>In practice, this is the key idea behind the <code>display_options</code> widget, a built-in feature that handles such mutations in a controlled fashion. If you are doing this using your own code, the following “gotchas” apply:</p>
<ul>
<li>LocusZoom layouts are nested and hierarchical (plot –&gt; panels[] –&gt; data_layers[]). See the helper functions below for advice on how to write mutations that are more readable and maintainable.</li>
<li>Be conservative in how many fields you allow to be changed. Layouts allow almost any aspect of the plot to be customized, but it can be difficult to test every possible combination. It’s generally easier to code and maintain controlled options (like a list of preset views).</li>
</ul>
<p>After re-defining the layout, be sure to call <code>plot.applyState()</code> (also known as <code>plot.refresh()</code>) to trigger a re-render, so that the changes to the layout take effect.</p>
<h3 id="helper-functions-for-modifying-nested-layouts">Helper functions for modifying nested layouts</h3>
<p>The “building block” style of layouts makes it easy to reuse pieces, but customizing part of a layout after rendering can be very clunky (example: <code>layout.panels[0].data_layers[1]</code>). In particular, if the order of elements in the layout ever changed (like adding a new panel or toolbar button), then code that accessed items by array position would break in ways that are very hard to debug. This is a maintainability headache.</p>
<p>As an alternative, a helper function <code>LocusZoom.Layouts.mutate_attrs</code> can be used to modify all parts of a layout that match a selector, using a readable syntax based on the <a href="https://goessner.net/articles/JsonPath/">JsonPath</a> query language. See the developer documentation for further details.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">// Add a field to a data layer, taking into account what fields are already there. The third argument is a function that receives the old value and returns the new one </span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="op">&gt;</span> LocusZoom<span class="op">.</span><span class="at">Layouts</span><span class="op">.</span><span class="fu">mutate_attrs</span>(plot_layout<span class="op">,</span> <span class="st">&#39;$..data_layers[?(@.tag === &quot;association&quot;)].fields&#39;</span><span class="op">,</span> (old_value) <span class="kw">=&gt;</span> old_value<span class="op">.</span><span class="fu">concat</span>([<span class="st">&#39;assoc:field1&#39;</span><span class="op">,</span> <span class="st">&#39;assoc:field2&#39;</span>]))<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co">// When the user clicks a button on the page, change what field is used for the y-axis for all association scatter plots. In this syntax, all matches receive the same value (the last argument is a value, instead of a callable function).</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="op">&gt;</span> LocusZoom<span class="op">.</span><span class="at">Layouts</span><span class="op">.</span><span class="fu">mutate_attrs</span>(existing_plot<span class="op">.</span><span class="at">layout</span><span class="op">,</span> <span class="st">&#39;$..data_layers[?(@.tag === &quot;association&quot;)].y_axis.field&#39;</span><span class="op">,</span> <span class="st">&#39;assoc:pip_cluster&#39;</span>)<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="op">&gt;</span> existing_plot<span class="op">.</span><span class="fu">applyState</span>()<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co">// The mutation function is not limited to changing scalar values or lists. If the selector targets a compound object, the function can be used to modify several properties all at once. Make sure to return the resulting config object when done.</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="op">&gt;</span> LocusZoom<span class="op">.</span><span class="at">Layouts</span><span class="op">.</span><span class="fu">mutate_attrs</span>(existing_plot<span class="op">.</span><span class="at">layout</span><span class="op">,</span> <span class="st">&#39;$..data_layers[?(@.tag === &quot;phewas&quot;)].color[?(@.scale_function === &quot;categorical_bin&quot;)]&#39;</span><span class="op">,</span> <span class="kw">function</span>(options) { options<span class="op">.</span><span class="at">field</span> <span class="op">=</span> <span class="st">&#39;newfield&#39;</span><span class="op">;</span> options<span class="op">.</span><span class="at">parameters</span><span class="op">.</span><span class="at">null_value</span> <span class="op">=</span> <span class="st">&#39;red&#39;</span> <span class="op">;</span> <span class="cf">return</span> options<span class="op">;</span> })<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="co">// For debugging purposes, there is a read-only function that can be used to verify that a selector works as expected. It will return a list, one item per result.</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="op">&gt;</span> LocusZoom<span class="op">.</span><span class="at">Layouts</span><span class="op">.</span><span class="fu">query_attrs</span>(plot_layout<span class="op">,</span> <span class="st">&#39;$..id&#39;</span>)<span class="op">;</span></span></code></pre></div>
<p><em>Notes:</em></p>
<p>We do not implement the entire JsonPath specification. The syntax used by LocusZoom:</p>
<ul>
<li>DOES support single child (<code>.</code>), deep nested (<code>..</code>), and wild-card (<code>*</code>) accessors</li>
<li>DOES support filtering arrays-of-config-objects to only items that match a simple single-attribute-exact-match predicate (<code>$.panels_array[?(@.akeyhasvalue === "targetvalue")]</code>)</li>
<li>DOES support queries that nest/combine operators (<code>$..data_layers[?(@.tag === 'association')].fields</code>)</li>
<li>DOES NOT support complex JS expressions in predicates (which would be a security issue), or indexing array items. (writing layouts based on item[0] is a maintainability anti-pattern, and we are actively trying to discourage doing that)</li>
<li>The end result of all selectors used should be to return a specific key inside an object. Lists can be filtered, but not indexed.</li>
</ul>
<p>Most pre-made data layer and panel layouts now contain a <code>tag</code> field, which can be used to write semantically meaningful selectors, like, “modify all scatter plots that show GWAS association data”.</p>
<blockquote>
<p>This helper function is aimed at making quick changes to one or two fields (before render), or more complex customizations (after render). If you are trying to make complex customizations to a layout when it is first defined, it is often better to build up in pieces so that you have more control of the result. For example, customizing a single data layer as part of a layout: <code>LocusZoom.Layouts.get('data_layer', 'association', { id: 'customoverridevalue' })</code>.</p>
</blockquote>
<h2 id="events-communicate-with-the-outside-world">Events communicate with the outside world</h2>
<p>Each time that a LocusZoom plot is modified, it fires an <em>event</em> that notifies any listeners of the change.</p>
<p>An event listener can be connected as follows. (note that the listener can contain any arbitrary code):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">const</span> listener <span class="op">=</span> plot<span class="op">.</span><span class="fu">on</span>(<span class="st">&#39;element_selection&#39;</span><span class="op">,</span> (<span class="bu">event</span>) <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="bu">event</span>))<span class="op">;</span> </span></code></pre></div>
<p>And the same event listener can be unregistered using the function handle for that listener:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1"></a>plot<span class="op">.</span><span class="fu">off</span>(<span class="st">&#39;element_selection&#39;</span><span class="op">,</span> listener)<span class="op">;</span></span></code></pre></div>
<p>Each time that an event callback is fired, it will receive one function argument, an object with the following keys:</p>
<ul>
<li><code>sourceID</code>: where the event originated. It is the fully qualified ID string relative to the top level: eg <code>lz_plot.association_panel</code></li>
<li><code>target</code> : the place where the event originated. This is a reference to either the <code>Plot</code> or <code>Panel</code> object.</li>
<li><code>data</code> : Each type of event may optionally provide additional information describing itself (such as “what point was clicked” or “was this point selected, or de-selected?”). The allowed fields are unique to each event type.</li>
</ul>
<p>Below is a partial list of interesting events; consult the documentation for a full guide to events and the data they emit.</p>
<ul>
<li><code>element_selection</code></li>
<li><code>element_annotation</code></li>
<li><code>panel_removed</code></li>
<li><code>region_changed</code></li>
<li><code>state_changed</code></li>
</ul>
<p>Custom widget or tooltip code can fire any event you want. For example, many widgets fire events to describe buttons that are clicked. Events are not limited to controlling the page- they can also be used in combination with page analytics to identify which options or features are being used the most.</p>
<h2 id="share-data-with-other-widgets-via-subscribetodata">Share data with other widgets via <code>subscribeToData</code></h2>
<p>Using the same mechanisms and syntax as an LZ data layer, let arbitrary parts of the page listen for new data by asking for the (namespaced) fields of interest.</p>
<p>Sample usage:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">// Receives exactly the same data as the specified datalayer ID (avoids having to duplicate namespace and data operations code)</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">const</span> spec <span class="op">=</span> { <span class="dt">from_layer</span><span class="op">:</span> <span class="st">&#39;panel1.layer1&#39;</span> }<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">const</span> success_callback <span class="op">=</span> (data) <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(data)<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="kw">const</span> opts <span class="op">=</span> { <span class="dt">onerror</span><span class="op">:</span> (err) <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(err) }<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a>plot<span class="op">.</span><span class="fu">subscribeToData</span>(spec<span class="op">,</span> success_callback<span class="op">,</span> opts)<span class="op">;</span></span></code></pre></div>
<p>When data is received, calls <em>success_callback</em> with the resulting data (an array of objects, with each object representing one datapoint). <code>subscribeToData</code> can be used to draw tables or companion visualizations on the page, separate from LocusZoom but automatically updating to stay in sync as the user clicks or pans across the plot. Specify <em>onerror</em> as an option to provide an error handling callback.</p>
<p>Sometimes you want exact control over what data is retrieved, rather than mirroring a data layer. In that case, replace <code>from_layer</code> with two options (<code>namespace</code> and <code>data_operations</code>) to manually specify how data is retrieved for this callback. See data layer documentation for syntax and usage.</p>
<h3 id="advanced-alternative">Advanced alternative</h3>
<p>Sometimes, the existing page already has several widgets sharing data, and it would be difficult to rewrite things after the fact in a way that ceded control of data to LocusZoom. In this case, some compromise needs to be reached: how can LocusZoom fetch what it needs (possibly rendering only a subset of the data available), without duplicating API calls to the server that have already been made elsewhere?</p>
<p>Reactive rendering frameworks sometimes solve the problem of sharing mutable data via a shared local cache (store) that represents data from the server. LocusZoom can then make requests to that store, and the store is then responsible for deciding whether a new server request is needed. This allows the result of a single API request to power all widgets on the page without redundant network traffic. The store call can then return a promise representing either local data, or the result of a server request, as appropriate.</p>
<p>In this model, if the data changed due to an external event, LocusZoom might need to be notified that new data is available. This is best done using the standard methods used to trigger a re-render from outside the plot (<code>plot.applyState()</code>).</p>
<p>If you are not using a store, this manual re-render can also be triggered by watching an observable value. (many frameworks provide a way to manually watch values for changes (<a href="https://vuejs.org/v2/guide/computed.html#Watchers">eg vue.js</a>).</p>
<h2 id="filters-control-what-is-shown">Filters control what is shown</h2>
<p>Filters can be used to control what elements are shown on a panel. This will hide elements, but preserve the space that those elements would have occupied: eg, the axis limits will reflect all of the data, not just what is currently shown.</p>
<p>Filters are specified in data layout layouts, and can be applied to most data layer types.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1"></a>{</span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="op">...</span><span class="at">options</span><span class="op">,</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>  <span class="dt">filters</span><span class="op">:</span> [</span>
<span id="cb5-4"><a href="#cb5-4"></a>    { <span class="dt">field</span><span class="op">:</span> <span class="st">&#39;{{namespace[access]}}score&#39;</span><span class="op">,</span> <span class="dt">operator</span><span class="op">:</span> <span class="st">&#39;!=&#39;</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="kw">null</span> }<span class="op">,</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>  ]<span class="op">,</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>}</span></code></pre></div>
<p>Scatter plots have an additional option to show labels for some or all data elements. This is controlled via adding a similar filter block inside <em>label</em>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1"></a>{</span>
<span id="cb6-2"><a href="#cb6-2"></a>  <span class="dt">id</span><span class="op">:</span> <span class="st">&#39;phewaspvalues&#39;</span><span class="op">,</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>  <span class="op">...</span><span class="at">options</span><span class="op">,</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>  <span class="dt">label</span><span class="op">:</span> {</span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;{{{{namespace[phewas]}}trait_label}}&#39;</span><span class="op">,</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="dt">filters</span><span class="op">:</span> [</span>
<span id="cb6-7"><a href="#cb6-7"></a>      {</span>
<span id="cb6-8"><a href="#cb6-8"></a>        <span class="dt">field</span><span class="op">:</span> <span class="st">&#39;{{namespace[phewas]}}log_pvalue&#39;</span><span class="op">,</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>        <span class="dt">operator</span><span class="op">:</span> <span class="st">&#39;&gt;=&#39;</span><span class="op">,</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>        <span class="dt">value</span><span class="op">:</span> <span class="dv">20</span><span class="op">,</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>      }<span class="op">,</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>    ]<span class="op">,</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>  }</span>
<span id="cb6-14"><a href="#cb6-14"></a>}</span></code></pre></div>
<p>The following filters are available:</p>
<ul>
<li><code>=</code>: field value <em>exactly</em> matches the provided value</li>
<li><code>!=</code>: field value <em>loosely</em> does not match the provided value (can be used to filter out falsy values such as undefined, null, or false)</li>
<li>Numerical comparisons: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
<li><code>in</code>: field value is present inside the provided value. The provided value can be a string, or, more commonly, an array: eg “gene type is one of the following”.</li>
<li><code>match</code>: the provided value is present in the field value. Useful for partial text search, eg “show only genes whose name contains the user-provided filter string”HLA"</li>
</ul>
<blockquote>
<p><em>NOTE:</em> If a list of multiple filters is provided, then <em>all</em> filter conditions must be true for an item to be shown in the plot.</p>
</blockquote>
<p>Filters can be modified interactively by the user after first render: see the <code>filter_field</code> widget for details.</p>
<h3 id="adding-your-own-custom-filter">Adding your own custom filter</h3>
<p>In some cases, a developer may wish to control the filter logic via a bit of custom code, if the built-in filters are too restrictive. Like many aspects of LocusZoom, the set of allowed filters can be extended via a plugin mechanism: you may use any filter operator defined in <code>LocusZoom.MatchFunctions.list()</code>.</p>
<p>To add your own comparison function, use: <code>LocusZoom.MatchFunctions.add('my_function', (item_value, target_value) =&gt; item_value === target_value)</code>. Custom filters can then be mixed and matched alongside the built-in filters.</p>
<p>A rarely used feature of filters is that it is possible to omit the <code>field</code> name, in which case the entire datum object of all fields is passed to the filter function: <code>{operator: 'my_other_function'}</code>. This is only useful with custom operators, because the built in <code>MatchFunctions</code> are all designed to operate on a single scalar value. Also, if used in this way, the custom filter function will need to know how to deal with namespacing in order to find the fields of interest. (each datum element will look like <code>{'assoc:log_pvalue': 12, 'assoc:variant': '1:23_A/C'}</code>) Still, in some rare cases, it can be useful to have a single filter function that examines more than one field at once.</p>
<h3 id="filters-can-transform-the-value-before-comparing">Filters can transform the value before comparing</h3>
<p>Sometimes, it is useful to transform a value before filtering. For example, many datasets store values in terms of <code>pvalue</code>, but you may wish to show significant hits in terms of <code>-log10 (pvalue)</code>. Filter syntax works with any transformation/template string function in LocusZoom:</p>
<pre><code>{
  ...options,
  filters: [
    { field: &#39;{{namespace[assoc]}}pvalue|neglog10&#39;, operator: &#39;&gt;=&#39;, value: 7.301 },
  ],
}</code></pre>
<h2 id="annotations-preserve-custom-options-across-re-render">Annotations preserve custom options across re-render</h2>
<p>LocusZoom typically maintains a separation of concerns, in which data layers are responsible for rendering the data provided by an adapter. For the most part, the display layer is not responsible for changing data, and it does not preserve state across renderings</p>
<p>However, there are some situations where a user might wish to modify how the data is shown: eg “show a label for this one specific point”.</p>
<p>The basic mechanism for this is called <em>annotations</em>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">// External code, or tooltips, may set a value</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>data_layer<span class="op">.</span><span class="fu">setElementAnnotation</span>(element_data<span class="op">,</span> key<span class="op">,</span> value)<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>data_layer<span class="op">.</span><span class="fu">getElementAnnotation</span>(item<span class="op">,</span> key)<span class="op">;</span></span></code></pre></div>
<p>Essentially, a rendering annotation stores an additional field for a given data point, but that field is stored internally rather than being sent by the data adapter. It can be used in any layout directive that operates on fields: size, shape, color, labels, etc.</p>
<p>The value can be anything you wish. However, LocusZoom works best when field values are primitives (like strings or integers).</p>
<p>Typically this is used by tooltips, allowing the user to click a link and modify how a point is shown. See the example below:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">const</span> tooltip <span class="op">=</span> {</span>
<span id="cb9-2"><a href="#cb9-2"></a>  <span class="co">// In this example, we take advantage of the fact that each tooltip is bound to the data for a specific point. Internally, D3 stores this information in a field called node.__data__, and we can use this to get the data for a tooltip.</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="dt">html</span><span class="op">:</span> <span class="vs">`&lt;a href=&quot;javascript:void(0);&quot; </span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="vs">          onclick=&quot;var item = this.parentNode.__data__, layer = item.getDataLayer(); </span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="vs">          var current = layer.getElementAnnotation(item, &#39;lz_show_label&#39;); </span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="vs">          layer.setElementAnnotation(item, &#39;lz_show_label&#39;, !current );</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="vs">          layer.parent_plot.applyState();&quot;&gt;Toggle label&lt;/a&gt;`</span><span class="op">;</span><span class="vs">`</span></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="vs">}</span></span>
<span id="cb9-9"><a href="#cb9-9"></a></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="vs">// The annotation is an additional field, but it doesn&#39;t come from the datasource. It can be used in any layout directive that operates on fields: size, shape, color, labels, etc..</span></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="vs">const scatter_layout = {</span></span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="vs">  ...options,</span></span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="vs">  label: {</span></span>
<span id="cb9-14"><a href="#cb9-14"></a><span class="vs">    ...label_options,</span></span>
<span id="cb9-15"><a href="#cb9-15"></a><span class="vs">    filters: [</span></span>
<span id="cb9-16"><a href="#cb9-16"></a><span class="vs">      { field: &#39;lz_show_label&#39;, operator: &#39;=&#39;, value: true }</span></span>
<span id="cb9-17"><a href="#cb9-17"></a><span class="vs">    ],</span></span>
<span id="cb9-18"><a href="#cb9-18"></a><span class="vs">  }</span></span>
<span id="cb9-19"><a href="#cb9-19"></a><span class="vs">};</span></span></code></pre></div>
<h2 id="matching-similar-elements-across-panels">Matching similar elements across panels</h2>
<p>The primary benefit of LocusZoom is to show results in context, allowing the user to create connections between multiple sources of information.</p>
<p>When a lot of data is being shown at once, it can be hard to identify exactly which points line up across tracks- each one is quite small! Fortunately, there is a mechanism by which two panels can communicate to find related elements: <em>matching</em>.</p>
<p>It works as follows:</p>
<ol type="1">
<li>In the layout, a directive is specified to opt in to this behavior: <code>match: {send: field_to_be_broadcast , receive: field_to_be_checked }</code></li>
<li>If a datalayer specifies <code>match.send</code>, then when any element is selected, the value of the specified field for that data element is broadcast to other layers. Eg if the user clicks on a scatter plot point, the variant ID for that point could be sent.</li>
<li>Whenever a match event is initiated, any data layer that specifies <code>match.receive</code> will examine each data point, and tag any point where the specified field value is the same as the broadcast value.</li>
<li>The special tag added to these points (<code>lz_is_match</code>) is treated as an extra field, and can be used in any scalable layout directive to control point size, shape, color, filters, etc. This field doesn’t come from the API or data adapter- it is an internal value that is checked on every render.</li>
</ol>
<p>Usage example:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1"></a>{</span>
<span id="cb10-2"><a href="#cb10-2"></a>  <span class="op">...</span><span class="at">options</span><span class="op">,</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>  <span class="co">// Note that a data layer can send AND receive. This means that it can respond to its own events: &quot;when a match point is clicked, turn that point red&quot;</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>  <span class="dt">match</span><span class="op">:</span> { <span class="dt">send</span><span class="op">:</span> <span class="st">&#39;{{namespace[access]}}target&#39;</span><span class="op">,</span> <span class="dt">receive</span><span class="op">:</span> <span class="st">&#39;{{namespace[access]}}target&#39;</span> }<span class="op">,</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>  <span class="dt">color</span><span class="op">:</span> [</span>
<span id="cb10-6"><a href="#cb10-6"></a>    {</span>
<span id="cb10-7"><a href="#cb10-7"></a>      <span class="dt">field</span><span class="op">:</span> <span class="st">&#39;lz_is_match&#39;</span><span class="op">,</span> <span class="co">// When a match is detected, it is tagged with a special field name that can be used to trigger custom rendering</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>      <span class="dt">scale_function</span><span class="op">:</span> <span class="st">&#39;if&#39;</span><span class="op">,</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>      <span class="dt">parameters</span><span class="op">:</span> {</span>
<span id="cb10-10"><a href="#cb10-10"></a>        <span class="dt">field_value</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>        <span class="dt">then</span><span class="op">:</span> <span class="st">&#39;#ff0000&#39;</span><span class="op">,</span></span>
<span id="cb10-12"><a href="#cb10-12"></a>      }<span class="op">,</span></span>
<span id="cb10-13"><a href="#cb10-13"></a>    }<span class="op">,</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>}</span></code></pre></div>
<blockquote>
<p><em>TIP:</em> Matching builds on the primitives described above: it responds to a specific internal event (<code>match_requested</code>), and broadcasts a field to all layers via <code>plot.state.lz_match_value</code> . This means that outside code can also cause the plot to render matching elements, by initiating the rendering update manually: <code>plot.applyState({lz_match_value: your_value_here })</code></p>
</blockquote>
<blockquote>
<p><em>NOTE:</em> For performance reasons, this feature is currently limited to simple rules. Only a single value may be broadcast across all data layers at one time, and only one field can be broadcast.</p>
</blockquote>
<h3 id="matching-rules-can-be-customized">Matching rules can be customized</h3>
<p>Matching is not limited to exact value equality. Using a third parameter (“operator”), matching rules can use any of the comparison functions in <code>LocusZoom.MatchFunctions</code>. As described in the description of filtering rules above, match rules can also take into account transforms that modify the field value before it is broadcast, or, how the broadcast value is compared to a specific field. Custom logic (operators) can also be added via MatchFunctions and accessed via name.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1"></a>{</span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="op">...</span><span class="at">options</span><span class="op">,</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="dt">match</span><span class="op">:</span> { <span class="dt">send</span><span class="op">:</span> <span class="st">&#39;{{namespace[access]}}target|htmlescape&#39;</span><span class="op">,</span> <span class="dt">receive</span><span class="op">:</span> <span class="st">&#39;{{namespace[access]}}target|htmlescape&#39;</span><span class="op">,</span> <span class="dt">operator</span><span class="op">:</span> <span class="st">&#39;!=&#39;</span> }<span class="op">,</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>}</span></code></pre></div>
<blockquote>
<p>NOTE: Remember that the template transforms are also extensible! Each <code>|templatefunction</code> refers to a function in <code>LocusZoom.TransformationFunctions</code>. Add your own via <code>LocusZoom.TransformationFunctions.add('my_function', (value) =&gt; othervalue)</code>. Custom plugins allow you to create very powerful custom presentations.</p>
</blockquote>
<h3 id="you-cannot-be-more-clever-than-your-underlying-data">You cannot be more clever than your underlying data</h3>
<p>In order to draw connections between two datapoints in different tracks, the two points must have some information in common.</p>
<p>This is easy enough when connecting similar kinds of data: two association datasets will both provide information about the variant ID, and it is very likely that the same variant will be identified the same way in both tracks.</p>
<p>For very different kinds of data, usually the API must be customized a bit to create commonality. For example, if you want to click on a gene and highlight association scatter points that are inside the gene, those scatter points would need to provide a <code>gene_id</code> field that used the same nomenclature as the one used by the genes track.</p>
<h1 id="built-in-features-to-simplify-interactivity">Built-in features to simplify interactivity</h1>
<p>The above mechanisms are very powerful, but they require a deep knowledge of LocusZoom’s internals to use effectively. We provide a number of low or no-code mechanisms to implement interactive plot features in controlled, well-tested ways.</p>
<h2 id="tooltips">Tooltips</h2>
<p>The first interactive feature that most LocusZoom users notice is the <em>tooltip</em>: a simple box that appears with more information when a user interacts with a point.</p>
<p>In addition to showing data associated with a field, tooltips can be customized with interactive action links that modify <code>plot.state</code> (eg setting the LD reference variant), or trigger annotations (like showing a label).</p>
<p>A tooltip is defined as an object describing when to display it, as well as the HTML template to render. It responds to the same LocusZoom template syntax supported elsewhere. For example, values can be embedded in the string with curly braces (<code>{{assoc:fieldname}}</code>) and a simple conditional syntax is supported to only render text if a value is defined: <code>{{#if sourcename:field_name}} Conditional text {{#else}} Optional else block {{/if}}</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1"></a>{</span>
<span id="cb12-2"><a href="#cb12-2"></a>  <span class="co">// Inherits namespaces from the layer that uses this tooltip</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>  <span class="dt">namespace</span><span class="op">:</span> { <span class="st">&#39;assoc&#39;</span><span class="op">:</span> <span class="st">&#39;assoc&#39;</span> }<span class="op">,</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>  <span class="dt">closable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>  <span class="co">// Show/hide logic is defined by the &quot;element status&quot; for a given piece of data. See `behaviors` for how these statuses get applied.</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>  <span class="dt">show</span><span class="op">:</span> { <span class="dt">or</span><span class="op">:</span> [<span class="st">&#39;highlighted&#39;</span><span class="op">,</span> <span class="st">&#39;selected&#39;</span>] }<span class="op">,</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>  <span class="dt">hide</span><span class="op">:</span> { <span class="dt">and</span><span class="op">:</span> [<span class="st">&#39;unhighlighted&#39;</span><span class="op">,</span> <span class="st">&#39;unselected&#39;</span>] }<span class="op">,</span></span>
<span id="cb12-8"><a href="#cb12-8"></a>  <span class="co">// The tooltip text is an HTML template with access to fields in the data. Be sure to apply HTML-escaping to any user-provided data.</span></span>
<span id="cb12-9"><a href="#cb12-9"></a>  <span class="dt">html</span><span class="op">:</span> <span class="vs">`&lt;strong&gt;{{{{namespace[assoc]}}variant|htmlescape}}&lt;/strong&gt;`</span><span class="op">,</span></span>
<span id="cb12-10"><a href="#cb12-10"></a>}</span></code></pre></div>
<h2 id="behaviors">Behaviors</h2>
<p>By default, almost every LocusZoom data element shows a tooltip on mouseover, and keeps that tooltip open when the element is clicked. However, this can be customized.</p>
<p>See below for an example of a layer where clicking a point acts as a link to a new page.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb13-1"><a href="#cb13-1"></a>{</span>
<span id="cb13-2"><a href="#cb13-2"></a>  <span class="op">...</span><span class="at">layer_options</span><span class="op">,</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>  <span class="dt">behaviors</span><span class="op">:</span> {</span>
<span id="cb13-4"><a href="#cb13-4"></a>    <span class="dt">onmouseover</span><span class="op">:</span> [</span>
<span id="cb13-5"><a href="#cb13-5"></a>      <span class="co">// Most tooltips are configured to appear when the element is highlighted (along with applying any other display tweaks to the page). A guide to statuses is outside the scope of this tutorial, but the default &quot;mouse move actions&quot; are shown for the sake of completeness.</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>      { <span class="dt">action</span><span class="op">:</span> <span class="st">&#39;set&#39;</span><span class="op">,</span> <span class="dt">status</span><span class="op">:</span> <span class="st">&#39;highlighted&#39;</span> }<span class="op">,</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>    ]<span class="op">,</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>    <span class="dt">onmouseout</span><span class="op">:</span> [</span>
<span id="cb13-9"><a href="#cb13-9"></a>      { <span class="dt">action</span><span class="op">:</span> <span class="st">&#39;unset&#39;</span><span class="op">,</span> <span class="dt">status</span><span class="op">:</span> <span class="st">&#39;highlighted&#39;</span> }<span class="op">,</span></span>
<span id="cb13-10"><a href="#cb13-10"></a>    ]<span class="op">,</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>    <span class="dt">onclick</span><span class="op">:</span> [</span>
<span id="cb13-12"><a href="#cb13-12"></a>        <span class="co">// The href parameter supports LocusZoom&#39;s template syntax, allowing data fields to be used in the URL</span></span>
<span id="cb13-13"><a href="#cb13-13"></a>      { <span class="dt">action</span><span class="op">:</span> <span class="st">&quot;link&quot;</span><span class="op">,</span> <span class="dt">href</span><span class="op">:</span> <span class="st">&quot;https://pheweb.org/pheno/{{{{namespace[phewas]}}phewas_code}}&quot;</span> }</span>
<span id="cb13-14"><a href="#cb13-14"></a>    ]<span class="op">,</span></span>
<span id="cb13-15"><a href="#cb13-15"></a>  }<span class="op">,</span></span>
<span id="cb13-16"><a href="#cb13-16"></a>}</span></code></pre></div>
<h2 id="toolbar-widgets">Toolbar Widgets</h2>
<h3 id="toggle-between-render-modes-with-display_options">Toggle between render modes with display_options</h3>
<p>The <code>display_options</code> widget renders a dropdown menu with several possible visualization settings. Each time an item is clicked, it will override the default properties.</p>
<p>To avoid duplication of code, the original display settings are automatically captured and shown as the “Default” option. Other options in the dropdown menu are specified as a list of layout directives that will be merged into the data layer.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">const</span> gene_selector_widget <span class="op">=</span> {</span>
<span id="cb14-2"><a href="#cb14-2"></a>  <span class="dt">type</span><span class="op">:</span> <span class="st">&#39;display_options&#39;</span><span class="op">,</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>  <span class="co">// Below: special config specific to this widget</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>  <span class="dt">button_html</span><span class="op">:</span> <span class="st">&#39;Filter...&#39;</span><span class="op">,</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>  <span class="dt">button_title</span><span class="op">:</span> <span class="st">&#39;Choose which genes to show&#39;</span><span class="op">,</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>  <span class="co">// If you are tracking website analytics, this widget can announce when it performs an action. Since this generic widget might be used in several different ways in the same plot, you can give each widget a custom event name to help tell the buttons apart.</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>  <span class="co">// This is totally optional- most sites will be fine just ignoring the event altogether!  </span></span>
<span id="cb14-8"><a href="#cb14-8"></a>  <span class="dt">custom_event_name</span><span class="op">:</span> <span class="st">&#39;widget_gene_filter_choice&#39;</span><span class="op">,</span></span>
<span id="cb14-9"><a href="#cb14-9"></a>  <span class="co">// Must specify the data layer id (within this panel) that will be controlled by the button</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>  <span class="dt">layer_name</span><span class="op">:</span> <span class="st">&#39;genes&#39;</span><span class="op">,</span></span>
<span id="cb14-11"><a href="#cb14-11"></a>  <span class="dt">default_config_display_name</span><span class="op">:</span> <span class="st">&#39;Coding genes &amp; rRNA&#39;</span><span class="op">,</span></span>
<span id="cb14-12"><a href="#cb14-12"></a>  <span class="dt">options</span><span class="op">:</span> [</span>
<span id="cb14-13"><a href="#cb14-13"></a>    <span class="co">// Specify how each item in the dropdown menu will work</span></span>
<span id="cb14-14"><a href="#cb14-14"></a>    {</span>
<span id="cb14-15"><a href="#cb14-15"></a>      <span class="dt">display_name</span><span class="op">:</span> <span class="st">&#39;All features&#39;</span><span class="op">,</span></span>
<span id="cb14-16"><a href="#cb14-16"></a>      <span class="dt">display</span><span class="op">:</span> {</span>
<span id="cb14-17"><a href="#cb14-17"></a>        <span class="dt">filters</span><span class="op">:</span> <span class="kw">null</span><span class="op">,</span></span>
<span id="cb14-18"><a href="#cb14-18"></a>      }<span class="op">,</span></span>
<span id="cb14-19"><a href="#cb14-19"></a>    }<span class="op">,</span></span>
<span id="cb14-20"><a href="#cb14-20"></a>  ]<span class="op">,</span></span>
<span id="cb14-21"><a href="#cb14-21"></a>}</span></code></pre></div>
<blockquote>
<p><em>NOTE:</em> The display options widget operates on a whitelist of layout directives: there are some things it cannot customize. This whitelist is expanded based on user requests. Rewriting (mutating) the entire layout is very powerful, and this gradual approach ensures that each new option is tested carefully before being added to a standard widget.</p>
</blockquote>
<h3 id="modify-data-retrieval-via-set_state">Modify data retrieval via set_state</h3>
<p>Some data adapters alter how they fetch information based on variables in <code>plot.state</code>. For example, the LDServer can choose to fetch LD from a particular reference population.</p>
<p>The <code>set_state</code> widget provides a way to set a particular variable (<code>state_field</code> ) to the provided value. When an option is clicked, it will trigger a re-render, including any updated data.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">const</span> ldlz2_pop_selector_menu <span class="op">=</span> {</span>
<span id="cb15-2"><a href="#cb15-2"></a>  <span class="co">// **Note**: this widget is aimed at the LDServer datasource, and the UM 1000G LDServer</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>  <span class="dt">type</span><span class="op">:</span> <span class="st">&#39;set_state&#39;</span><span class="op">,</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>  <span class="dt">button_html</span><span class="op">:</span> <span class="st">&#39;LD Population: &#39;</span><span class="op">,</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>  <span class="dt">show_selected</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>  <span class="dt">button_title</span><span class="op">:</span> <span class="st">&#39;Select LD Population: &#39;</span><span class="op">,</span></span>
<span id="cb15-7"><a href="#cb15-7"></a>  <span class="dt">state_field</span><span class="op">:</span> <span class="st">&#39;ld_pop&#39;</span><span class="op">,</span></span>
<span id="cb15-8"><a href="#cb15-8"></a>  <span class="co">// This list below is hardcoded to work with the UMich LDServer, default 1000G populations</span></span>
<span id="cb15-9"><a href="#cb15-9"></a>  <span class="co">//  It can be customized to work with other LD servers that specify population differently</span></span>
<span id="cb15-10"><a href="#cb15-10"></a>  <span class="co">// https://portaldev.sph.umich.edu/ld/genome_builds/GRCh37/references/1000G/populations</span></span>
<span id="cb15-11"><a href="#cb15-11"></a>  <span class="dt">options</span><span class="op">:</span> [</span>
<span id="cb15-12"><a href="#cb15-12"></a>    { <span class="dt">display_name</span><span class="op">:</span> <span class="st">&#39;ALL (default)&#39;</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="st">&#39;ALL&#39;</span> }<span class="op">,</span></span>
<span id="cb15-13"><a href="#cb15-13"></a>    { <span class="dt">display_name</span><span class="op">:</span> <span class="st">&#39;AFR&#39;</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="st">&#39;AFR&#39;</span> }<span class="op">,</span></span>
<span id="cb15-14"><a href="#cb15-14"></a>    { <span class="dt">display_name</span><span class="op">:</span> <span class="st">&#39;AMR&#39;</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="st">&#39;AMR&#39;</span> }<span class="op">,</span></span>
<span id="cb15-15"><a href="#cb15-15"></a>    { <span class="dt">display_name</span><span class="op">:</span> <span class="st">&#39;EAS&#39;</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="st">&#39;EAS&#39;</span> }<span class="op">,</span></span>
<span id="cb15-16"><a href="#cb15-16"></a>    { <span class="dt">display_name</span><span class="op">:</span> <span class="st">&#39;EUR&#39;</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="st">&#39;EUR&#39;</span> }<span class="op">,</span></span>
<span id="cb15-17"><a href="#cb15-17"></a>    { <span class="dt">display_name</span><span class="op">:</span> <span class="st">&#39;SAS&#39;</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="st">&#39;SAS&#39;</span> }<span class="op">,</span></span>
<span id="cb15-18"><a href="#cb15-18"></a>  ]<span class="op">,</span></span>
<span id="cb15-19"><a href="#cb15-19"></a>}<span class="op">;</span></span></code></pre></div>
<h3 id="control-what-is-shown-with-filter_field">Control what is shown with filter_field</h3>
<p>Sometimes, a region plot has a lot of information, and the user wants to restrict what is shown. This can be helpful in coaccessibility tracks, for example, which have a very large number of loops.</p>
<p>This widget appears as a text box in panel toolbars. Options allow control over a specific filter,</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1"></a>{</span>
<span id="cb16-2"><a href="#cb16-2"></a>  <span class="dt">type</span><span class="op">:</span> <span class="st">&#39;filter_field&#39;</span><span class="op">,</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>  <span class="co">// Must specify the data layer id relative to the panel in which this widget appears</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>  <span class="dt">layer_name</span><span class="op">:</span> <span class="st">&#39;coaccessibility&#39;</span><span class="op">,</span></span>
<span id="cb16-5"><a href="#cb16-5"></a>  <span class="dt">field</span><span class="op">:</span> <span class="st">&#39;{{namespace[access]}}score&#39;</span><span class="op">,</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>  <span class="dt">field_display_html</span><span class="op">:</span> <span class="st">&#39;Score&#39;</span><span class="op">,</span></span>
<span id="cb16-7"><a href="#cb16-7"></a>  <span class="dt">operator</span><span class="op">:</span> <span class="st">&#39;&gt;=&#39;</span><span class="op">,</span></span>
<span id="cb16-8"><a href="#cb16-8"></a>  <span class="co">// Optionally, the value entered into the text box can be coerced into a number.</span></span>
<span id="cb16-9"><a href="#cb16-9"></a>  <span class="dt">data_type</span><span class="op">:</span> <span class="st">&#39;number&#39;</span><span class="op">,</span></span>
<span id="cb16-10"><a href="#cb16-10"></a>}</span></code></pre></div>
<h2 id="extensions">Extensions</h2>
<h3 id="create-shareable-region-links-with-dynamicurls">Create shareable region links with DynamicUrls</h3>
<p>A major feature of LocusZoom is the ability to update the plot in response to user events. When a user finds an interesting view, they often wish to share that exact region with colleagues.</p>
<p>We provide an optional LocusZoom extension to help with this. It can be added via a script tag (<code>dist/ext/lz-dynamic-urls.min.js</code>)</p>
<p>The plot region will appear in the URL as query parameters. For example, <code>https://statgen.github.io/locuszoom/?chrom=10&amp;start=114550452&amp;end=115067678</code></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1"></a><span class="co">////// Before creating the plot, check the URL to see if a specific viewing region has requested. If so, make that the default when the plot is first rendered.</span></span>
<span id="cb17-2"><a href="#cb17-2"></a></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="co">// The web site owner has control over how their URL looks. Here, the parameter &quot;chr&quot; appears in the URL as &quot;chrom&quot;. Any top-level parameter in plot.state can be serialized into the URL. LocusZoom will only try to manage the parameters named here.</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="kw">var</span> stateUrlMapping <span class="op">=</span> {<span class="dt">chr</span><span class="op">:</span> <span class="st">&quot;chrom&quot;</span><span class="op">,</span> <span class="dt">start</span><span class="op">:</span> <span class="st">&quot;start&quot;</span><span class="op">,</span> <span class="dt">end</span><span class="op">:</span> <span class="st">&quot;end&quot;</span>}<span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="kw">var</span> initialState <span class="op">=</span> LzDynamicUrls<span class="op">.</span><span class="fu">paramsFromUrl</span>(stateUrlMapping)<span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="cf">if</span> (<span class="op">!</span><span class="bu">Object</span><span class="op">.</span><span class="fu">keys</span>(initialState)<span class="op">.</span><span class="at">length</span>) {</span>
<span id="cb17-7"><a href="#cb17-7"></a>    initialState <span class="op">=</span> {<span class="dt">chr</span><span class="op">:</span> <span class="dv">10</span><span class="op">,</span> <span class="dt">start</span><span class="op">:</span> <span class="dv">114550452</span><span class="op">,</span> <span class="dt">end</span><span class="op">:</span> <span class="dv">115067678</span>}<span class="op">;</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>}</span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="co">// Draw the plot, providing the desired region to draw</span></span>
<span id="cb17-10"><a href="#cb17-10"></a><span class="kw">const</span> layout <span class="op">=</span> LocusZoom<span class="op">.</span><span class="at">Layouts</span><span class="op">.</span><span class="fu">get</span>(<span class="st">&quot;plot&quot;</span><span class="op">,</span> <span class="st">&quot;standard_association&quot;</span><span class="op">,</span> {<span class="dt">state</span><span class="op">:</span> initialState})<span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11"></a><span class="bu">window</span><span class="op">.</span><span class="at">plot</span> <span class="op">=</span> LocusZoom<span class="op">.</span><span class="fu">populate</span>(<span class="st">&quot;#lz-plot&quot;</span><span class="op">,</span> data_sources<span class="op">,</span> layout)<span class="op">;</span></span>
<span id="cb17-12"><a href="#cb17-12"></a></span>
<span id="cb17-13"><a href="#cb17-13"></a><span class="co">// Set up event listeners: Changes in the plot can be reflected in the URL, and vice versa (eg browser back button can go back to</span></span>
<span id="cb17-14"><a href="#cb17-14"></a><span class="co">//   a previously viewed region)</span></span>
<span id="cb17-15"><a href="#cb17-15"></a>LzDynamicUrls<span class="op">.</span><span class="fu">plotUpdatesUrl</span>(plot<span class="op">,</span> stateUrlMapping)<span class="op">;</span></span>
<span id="cb17-16"><a href="#cb17-16"></a>LzDynamicUrls<span class="op">.</span><span class="fu">plotWatchesUrl</span>(plot<span class="op">,</span> stateUrlMapping)<span class="op">;</span></span></code></pre></div>
<blockquote>
<p><em>Note</em>: If your web site is a single page application (like vue-router), then another piece of javascript may already be controlling the page URL. DynamicUrls is mainly intended for web sites where the server returns the HTML for each page.</p>
</blockquote>
<h4 id="advanced-usage">Advanced usage</h4>
<p>Most usages of dynamic URLs are very simple, eg show a particular plot region.</p>
<p>In reality, some highly advanced sites may wish to copy other information into the URL that is not part of <code>plot.state</code>. Since a URL is a string, the task of sending information from the URL to the plot is essentially a problem of <em>serialization</em> (plot –&gt; URL) or <em>deserialization</em> (url –&gt; plot).</p>
<p>The way that query parameter data can be found and applied to the plot can be completely controlled by passing a third argument (<em>callback</em>) to <code>plotWatchesUrl</code> and <code>plotUpdatesUrl</code>. See the source code for details.</p>
</body>
</html>
